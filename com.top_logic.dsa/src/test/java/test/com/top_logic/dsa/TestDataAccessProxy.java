/*
 * SPDX-FileCopyrightText: 2002 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package test.com.top_logic.dsa;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.List;

import junit.extensions.TestSetup;
import junit.framework.Test;
import junit.framework.TestSuite;

import test.com.top_logic.basic.BasicTestCase;
import test.com.top_logic.basic.TestUtils;
import test.com.top_logic.basic.module.ServiceTestSetup;

import com.top_logic.basic.Logger;
import com.top_logic.basic.io.FileUtilities;
import com.top_logic.dob.DataObject;
import com.top_logic.dob.MetaObject;
import com.top_logic.dob.util.MetaObjectUtils;
import com.top_logic.dsa.DAPropertyNames;
import com.top_logic.dsa.DataAccessProxy;
import com.top_logic.dsa.DataAccessService;
import com.top_logic.dsa.DatabaseAccessException;
import com.top_logic.dsa.ex.NotSupportedException;

/**
 * Testing the TestDataAccessProxy (and DataSourceAdaptor) implementations.
 *
 * @author  <a href="mailto:kha@top-logic.com">Klaus Halfmann</a>
 */
public class TestDataAccessProxy extends BasicTestCase {

    /** DemoDate used for Streamning */
    public static final byte DATA[] = 
		("This is some Data generated by " + TestDataAccessProxy.class.getName()).getBytes();

    /** Array of names known to have problems */
    public static final String NAMES[] =  {
            "Test Name",
            "TestName",
            "_name_with_underscores_",
            "_°^!§$%&)(][}{=` ´+~'#,.-_",
            "~$name with Tilde and Dollar~",
            "~name with Tilde~"
        };

    /** Array of names als List */
    public static final List NAMESL = Arrays.asList(NAMES);

	private static final boolean NOFORCE = false;

    /**
     * Default Constructor
     *
     * @param name      name of fucntion to execute for testing
     */
    public TestDataAccessProxy (String name) {
        super (name);
    }

    /** Create an InputStream with some demo-Data */
    protected static InputStream getInputStream() {
        return new ByteArrayInputStream(DATA);
    }

    /**
     * Check some basic Attributes of the DSA to intialize the info
     */
    public void doFirst() throws Exception {
    
        DAPInfo info = DAPInfo.currInfo;
        DataAccessProxy root = new DataAccessProxy(info.protocol);
        info.root = root;
        
        info.isStructured = root.isStructured();
        info.isRepository = root.isRepository ();
        info.isPrivate    = root.isPrivate ();
        
        if (info.isPrivate) {
            BasicTestCase.createNamedTestFile("home/guest/").mkdir();
        }


        info.entry      = new DataAccessProxy(root.createEntry("TestEntry", getInputStream()));
        info.container  = root.createContainerProxy("TestContainer");
    }
    
    /**
     * Test root Level access to a DataSource.
     */
    public void testRoot() throws Exception {
        
        DAPInfo info = DAPInfo.currInfo;
        DataAccessProxy root = info.root;

        DataAccessProxy top1 = new DataAccessProxy(info.protocol , "topElement");
        DataAccessProxy top2 = new DataAccessProxy(root          , "topElement");
        DataAccessProxy top3 = new DataAccessProxy(info.protocol + "topElement");
        DataAccessProxy top4 = root.getChildProxy("topElement");
        
        assertEquals(top1, top2);
        assertEquals(top2, top3);
        assertEquals(top1, top3);
        assertEquals(top1, top4);
        assertEquals(top2, top4);
        assertEquals(top3, top4);
        
        assertTrue("Root node should exist for '" + info.protocol + "'", root.exists());

        // Even the root node might be an entry ,,,,
        root.isContainer();
        root.isEntry();

        String test = root.getName();       
        assertEquals("", test);
        test = root.getPath();
        assertEquals(info.protocol, root.getPath());
        assertNull  (root.getParent());
        assertNull  (root.getParentProxy());
    }
    
    
    /** Helper function for testContainer, conatiner will be deleted in a final Step
     *
     * @param container must be an existing container.
     */
    protected void doTestContainer(DataAccessProxy container) 
        throws DatabaseAccessException, IOException {
    
        DataAccessProxy sub = new DataAccessProxy(container.createContainer("subcontainer"));
        try  {
            assertTrue(sub.exists());
            assertTrue(sub.isContainer());
            try {
                container.createContainer("subcontainer");
                fail ("Should not be able to create a container twice for " + container);
            } catch (DatabaseAccessException expected)  { /* expected */ }
            try {
                container.createContainerProxy("subcontainer");
                fail ("Should not be able to create a container twice for " + container);
            } catch (DatabaseAccessException expected)  { /* expected */ }
            assertNull(sub.getEntryNames());
            assertNull(sub.getEntries());
        
            String[] sentries = container.getEntryNames();
            String   path     = sub.getPath();
            assertTrue("Entries should contain " + sub , 
                        Arrays.asList(sentries).contains(path));
           
            DataAccessProxy[] entries = container.getEntries();
            assertTrue("Entries should contain " + sub , 
                        Arrays.asList(entries).contains(sub));
        }
        finally  {        
            sub.delete(NOFORCE);
            assertTrue(!sub.exists());
        }
    }
    
    /** Test container based access to DSA (if possible) */
    public void testContainer() 
        throws DatabaseAccessException, IOException {
   
        DAPInfo info = DAPInfo.currInfo;
        if (info.root.isContainer())
            doTestContainer(info.root);
        DataAccessProxy container = info.container;
        doTestContainer(container);
        
        int depth = 10;
        DataAccessProxy subs[] = new DataAccessProxy[depth];
        for (int i=0; i < depth; i++)
            container = subs[i] = container.createContainerProxy("subcontainer");

        try {
            subs[0].deleteRecursively();    
        } catch (NotSupportedException nse) {
            // Do it the hard way ...
            for (int i=depth - 1; i >= 0; i--)
                subs[i].delete(NOFORCE);
        }

        for (int i=0; i < depth; i++)
            assertTrue(!subs[i].exists());

    }
    
    /** Test the standartProperties. */
    protected void doTestStandardProperties(DataAccessProxy aDAP, DataObject aProperties) throws Exception {
        // test standard properties
        MetaObject theMeta = aProperties.tTable();
        Object attr = null;
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.SIZE)) {
            attr = aProperties.getAttributeValue(DAPropertyNames.SIZE);
            if (attr != null)
                assertTrue(attr instanceof Long);
        }
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.LAST_MODIFIED)) {
            attr = aProperties.getAttributeValue(DAPropertyNames.LAST_MODIFIED);
            if (attr != null)
                assertTrue(aDAP.getPath() + 
                    " expected Long but was " + attr.getClass(),
                     attr instanceof Long);
        }
        // ensure the returned value is of type Boolean
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.IS_READABLE)) {
            attr = aProperties.getAttributeValue(DAPropertyNames.IS_READABLE);
            if (attr != null)
                assertTrue(attr instanceof Boolean);
        }
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.IS_WRITEABLE)) {
            attr = aProperties.getAttributeValue(DAPropertyNames.IS_WRITEABLE);
            if (attr != null)
                assertTrue(attr instanceof Boolean);
        }
        Boolean isEntry     = null;
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.IS_ENTRY))
            isEntry = (Boolean)aProperties.getAttributeValue(DAPropertyNames.IS_ENTRY);
        Boolean isContainer = null;
         if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.IS_CONTAINER))
           isContainer = (Boolean)aProperties.getAttributeValue(DAPropertyNames.IS_CONTAINER);
        Boolean exists      = null;
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.EXISTS))
            exists = (Boolean)aProperties.getAttributeValue("exists");
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.LOCKED)) {
            attr = aProperties.getAttributeValue("locked");
            if (attr != null)
                assertTrue(attr instanceof Boolean);
        }
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.DELETED)) {
            attr = aProperties.getAttributeValue(DAPropertyNames.DELETED);
            if (attr != null)
                assertTrue(attr instanceof Boolean);
        }
        // ensure the returned value is of type String
        String name   = null;
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.NAME)) 
            name = (String)aProperties.getAttributeValue(DAPropertyNames.NAME);
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.AUTHOR)) {
            attr = aProperties.getAttributeValue(DAPropertyNames.AUTHOR);
            if (attr != null)
                assertTrue(attr instanceof String);
        }
        if (MetaObjectUtils.hasAttribute(theMeta, DAPropertyNames.LOCKER)) {
            attr = aProperties.getAttributeValue(DAPropertyNames.LOCKER);
            if (attr != null)
                assertTrue(attr instanceof String);
        }
        // check returned values
        if (isEntry != null)
            assertEquals(
                "Wrong value in isEntry property.",
                isEntry.booleanValue(),
                aDAP.isEntry());
        if (isContainer != null)
            assertEquals(
                "Wrong value in isContainer property.",
                isContainer.booleanValue(),
                aDAP.isContainer());
        if (exists != null)
            assertEquals(
                "Wrong value in exists property.",
                exists.booleanValue(),
                aDAP.exists());
        if (name != null)
            aDAP.getName();
            assertEquals(
                "Wrong value in name property.",
                aDAP.getName(), name);
    }

    /** Test Properties (very specific) */
    public void testProperties() throws Exception {

        DAPInfo info = DAPInfo.currInfo;
        /* DataObject theRootProp = */ info.root.getProperties();
        
        // test standard properties
        // Must DSAs do not create corretc properties for root elements
        // doTestStandardProperties(info.root     , theRootProp);
        doTestStandardProperties(info.container, info.container.getProperties());
        doTestStandardProperties(info.entry    , info.entry.getProperties());
        
        /*
            setProperties();    // what can be done here ???
        */
    }

    /** Test structured acces to DSA (if possible) */
    public void testStructured() {
        
        /*
        DAPInfo info = DAPInfo.currInfo;
        DataAccessProxy root =  info.root;
        if (!info.isStructured) {
            assertNull(root.getObjectEntry());
            assertNull(root.getObjectEntry("Version"));
        }
        else {
            assertNotNull(root.getObjectEntry());
            assertNotNull(root.getObjectEntry("Version"));
        }
        */
    }

    /** Helper function for testEntries, entry will be deleted in a final Step
     *
     * @param entry must be an existing entry.
     */
    protected void doTestEntry(DataAccessProxy entry) 
        throws DatabaseAccessException, IOException {
    
        assertTrue(entry.exists());
        try {
            DataAccessProxy parent = entry.getParentProxy();
            try  {
                new DataAccessProxy(
                    parent.createEntry(entry.getName(), getInputStream()));
                fail("createEntry() with existing Entry must fail");
            } catch (DatabaseAccessException expected)  { /* expected */ }
            
            entry.putEntry(getInputStream());
            
			InputStream in1 = entry.getEntry();
			try {
				InputStream in2 = getInputStream();
				try {
					assertTrue(FileUtilities.equalsStreamContents(in1, in2));
				} finally {
					in2.close();
				}
			} finally {
				in1.close();
			}

            try {
            InputStream input = getInputStream();
				OutputStream output = entry.getEntryOutputStream();
			try {
				try {
					FileUtilities.copyStreamContents(input, output);
				} finally {
					output.close();
				}
			}
			finally {
			    input.close();
			}
			InputStream in11 = entry.getEntry();
			try {
				InputStream in2 = getInputStream();
				try {
					assertTrue(FileUtilities.equalsStreamContents(in11, in2));
				} finally {
					in2.close();
				}
			} finally {
				in11.close();
			}
            }
            catch (NotSupportedException nse)  { 
                // well 
            }
      
        } finally  {
            if (entry.isRepository())
                entry.unlock();
            entry.delete(NOFORCE);
        }
    }
    
    
    /** Test handling of entries (stream based, if possible) */
    public void testEntry() throws Exception {

        DAPInfo info = DAPInfo.currInfo;

        // Try entry just below root
        doTestEntry(new DataAccessProxy(
            info.root.createEntry("NewTestEntry", getInputStream())));
        
        // Try entry inside a container
        doTestEntry(new DataAccessProxy(
            info.container.createEntry("NewTestEntry", getInputStream())));

        try  {
           new DataAccessProxy(info.root,"Some crazy name that should not exist")
            .putEntry (getInputStream());
            fail("putEntry() with not existing Entry must fail for " + info.root);
        } catch (DatabaseAccessException expected)  { /* expected */ }

        try  {
            new DataAccessProxy(info.container,"Some crazy name that should not exist")
             .putEntry (getInputStream());
            fail("putEntry() with not existing Entry must fail for " + info.container);
        } catch (DatabaseAccessException expected)  { /* expected */ }

        /*
        putEntry(do)
        OutputStrem os = getEntryOutputStream();
        getURL();
        getForwardURL
        OutputStream os = createEntry("name");

        DataAccesProxy root =  info.root;
        if (info.isStructured()) {
            InputStream is = root.getEntry();
            assertNotNull(is);
            is.close();
            InputStream is = root.getEntry("Version");
            assertNotNull(is);
            is.close();
        }
        else {
            assertNull(root.getObjectEntry());
            assertNull(getObjectEntry("Version"));
            putEntry
        }

        rename
        
        getEntry("Version");
        */
    }

    /** Test repository based acces to DSA (if possible) */
    public void testRepository() throws DatabaseAccessException, IOException {

        DAPInfo info = DAPInfo.currInfo;

        if (!info.root.isRepository())
            return;
        
        info.entry.lock();
        info.entry.lock();
        
        info.entry.unlock();
        info.entry.unlock();
		InputStream in1 = info.entry.getEntry("1");
		try {
			InputStream in2 = getInputStream();
			try {
				assertTrue(FileUtilities.equalsStreamContents(in1, in2));
			} finally {
				in2.close();
			}
		} finally {
			in1.close();
		}
    }

    /** Testthings that may kill the DSA ;->>  */
    public void testEvil() {
        /*
       fireDataChanged
       */
    }

    /**
     * Clean up the test Objects cerated for the info
     */
    public void doLast() throws Exception {

        DAPInfo info = DAPInfo.currInfo;
        if (info.entry != null)
            info.entry.delete(NOFORCE);
        if (info.container != null) {
            try  {
                info.container.deleteRecursively();
            }
            catch (NotSupportedException nsx)  {
                // Try to delete at least container
                info.container.delete(NOFORCE);
            }
        }
    }

    /**
     * main function for direct testing.
     */
    public static void main (String[] args)  throws IOException  {
    	
        Logger.configureStdout("ERROR");
    	BasicTestCase.deleteTestDir();
    	
        junit.textui.TestRunner.run (suite ());
    }

    
    // inner class used to carry around some information shared by the tests.
    
    static class DAPInfo extends TestSetup {

        /** The Protocol of the DataAccessProxy to test. */
        static DAPInfo currInfo;
        
        /** SetuUp the context with the current instance */
        @Override
		public void setUp() {
            currInfo = this;
             // System.err.println("now Testing " + protocol);
        }
        
        /** CleanUp the context, just to be sure */
        @Override
		public void tearDown() {
            currInfo = null;
        }

        /** The Protocol of the DataAccessProxy to test. */
        String protocol;

        /** Proxy to root context, should always exist */
        DataAccessProxy  root;

        /** If possible an existing entry, else null */
        DataAccessProxy entry;

        /** If possible an existing (non-root) container, else null */
        DataAccessProxy container;
        
        /** result of istStructured() */
        boolean isStructured;

        /** result of isRepository() */
        boolean isRepository;

        /** result of isPrivate() */
        boolean isPrivate;
        
        /** Construct new DAPInfo for given protocol, wrapping the gicen Test(s) */
        public DAPInfo(Test toWrap, String aProtocol) {
            super (toWrap);
            protocol = aProtocol + DataAccessProxy.SEPARATOR;
        }
    
    }
    
    /**
     * the suite of tests to perform
     */
    public static Test suite ()  {
        TestSuite suite = new TestSuite ();

		suite.addTest(TestUtils.tryEnrichTestnames(createInner("testFile"), "testFile"));
		suite.addTest(TestUtils.tryEnrichTestnames(createInner("testRepository"), "testRepository"));
            
        Test innerTest = ServiceTestSetup.createSetup(suite, DataAccessService.Module.INSTANCE);
		return DSATestSetup.createDSATestSetup(innerTest);
    }

	private static Test createInner(String protoname) {
		TestSuite psuite = new TestSuite ();                
		psuite.addTest(new TestDataAccessProxy("doFirst"));
		psuite.addTest(new TestSuite(TestDataAccessProxy.class));
		psuite.addTest(new TestDataAccessProxy("doLast"));
		
		return new DAPInfo(psuite, protoname);
	}

    
}
