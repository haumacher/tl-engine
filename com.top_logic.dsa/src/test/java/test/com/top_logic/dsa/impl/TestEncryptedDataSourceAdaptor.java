/*
 * SPDX-FileCopyrightText: 2000 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package test.com.top_logic.dsa.impl;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

import test.com.top_logic.basic.module.ServiceTestSetup;
import test.com.top_logic.dsa.DSATestSetup;

import com.top_logic.basic.config.SimpleInstantiationContext;
import com.top_logic.basic.config.TypedConfiguration;
import com.top_logic.basic.encryption.EncryptionService;
import com.top_logic.basic.io.FileUtilities;
import com.top_logic.dob.DataObject;
import com.top_logic.dob.ex.NoSuchAttributeException;
import com.top_logic.dsa.DAPropertyNames;
import com.top_logic.dsa.DataSourceAdaptor;
import com.top_logic.dsa.DatabaseAccessException;
import com.top_logic.dsa.evt.DataChangeEvent;
import com.top_logic.dsa.evt.DataChangeListener;
import com.top_logic.dsa.ex.DataChangeException;
import com.top_logic.dsa.file.FilesystemDataSourceAdaptor;
import com.top_logic.dsa.impl.EncryptedDataSourceAdaptor;

/**
 * Testcase for the {@link com.top_logic.dsa.impl.EncryptedDataSourceAdaptor}.
 */
public class TestEncryptedDataSourceAdaptor extends TestCase implements DataChangeListener {

	private static final String TEST_HOME = "tmp/EDSA";

	/** DemoDate used for Streamning */
    public static final byte DATA[] = 
		("This is some Data generated by " + TestEncryptedDataSourceAdaptor.class.getName()).getBytes();

    /** Array of names known to have problems */
    public static final String NAMES[] =  {
            "Test Name",
            "TestName",
            "_name_with_underscores_",
            "_^!$%&)(][}{=` +~'#,.-_",
            "~$name with Tilde and Dollar~",
            "~name with Tilde~"
            /*
             // This will not work in Solaris °, §, ´ are no ascii characters
            "_°^!§$%&)(][}{=` ´+~'#,.-_",
             // This will not work in NT or Unix due to / \ resp. ;
            " °^!\"§$%&/)(][}{=?\\`´*+~'#,.;:-_|><"
            */
        };

    /** Array of names als List */
    public static final List NAMESL = Arrays.asList(NAMES);

	private static final boolean NOFORCE = false;

    /** Last event we got via the DataChangeListener interface */
    protected Stack events = new Stack();
    
    /** Result returned by checkChangeAllow for Testing */
    protected boolean           allow = true;

    /**
     * Default constructor.
     *
     * @param name of test to execute.
     */
    public TestEncryptedDataSourceAdaptor (String name) {
        super (name);
    }

	@Override
	protected void setUp() throws Exception {
		super.setUp();
		File dir = new File(TEST_HOME);
		assertTrue("Unable to create directory " + dir, dir.mkdir());
	}

	@Override
	protected void tearDown() throws Exception {
		FileUtilities.deleteR(new File(TEST_HOME));
		super.tearDown();
	}

    /** Create an InputStream with some demo-Data */
    protected InputStream getInputStream() {
        return new ByteArrayInputStream(DATA);
    }

    /** Just Record the Event for later checking.
     */
    @Override
	public void dataChanged (DataChangeEvent anEvent)  {
        if (events != null)
            events.push(anEvent);
    }

    /**
     * This method will be called before the change of data will be done.
     *
     * If, and only if, no listener is throwing an exception, the change 
     * will be allowed and executed. This method is needed, if the changes 
     * in the system will affect securiy reasons.
     *
     * @param    anEvent                The event holding the information
     *                                  about the change.
     * @throws   DataChangeException    Thrown, when the change is not allowed,
     *                                  the contained message should explain
     *                                  the reason.
     */
    @Override
	public void checkChangeAllow (DataChangeEvent anEvent) 
        throws DataChangeException {
        if (!allow)
            throw new DataChangeException("Not allowed (Testing)");
    }
    
    /** Return the Last Event and Clear it meanwhile */ 
    protected DataChangeEvent getLastEvent() {
        return (DataChangeEvent) events.pop();
    }
    
    /**
     * Pseudo test to cleanup the tmp directory
     */
    public void cleanupTmp ()  {
        File tmpFile        = new File("tmp");
        File repositoryFile = new File("tmp/repository");
        File workareaFile   = new File("tmp/workarea");
        
        FileUtilities.deleteR(tmpFile);
        
        tmpFile.       mkdir();
        repositoryFile.mkdir();    
        workareaFile.  mkdir();    
    }

    // actual TestMethods start here

    /**
     * Test Main functions of the dsa...
     */
    public void testMain () throws Exception {
        // Setup EncryptedDataSourceAdaptor via properties
		FilesystemDataSourceAdaptor.Config implConf =
			TypedConfiguration.newConfigItem(FilesystemDataSourceAdaptor.Config.class);
		implConf.setImplementationClass(FilesystemDataSourceAdaptor.class);
		implConf.setHome(TEST_HOME);

		EncryptedDataSourceAdaptor.Config encryptedConf =
			TypedConfiguration.newConfigItem(EncryptedDataSourceAdaptor.Config.class);
		encryptedConf.setImplementation(implConf);

		EncryptedDataSourceAdaptor edsa =
			SimpleInstantiationContext.CREATE_ALWAYS_FAIL_IMMEDIATELY.getInstance(encryptedConf);
        edsa.setProtocol("TestEncryptedDataSourceAdaptor");
        
        assertTrue(!edsa.isRepository());
        int l = NAMES.length;
                
        // Create directories
        for (int i=0; i < l; i++) {
            String dirName  = NAMES[i];
            String xDirName = edsa.createContainer("", dirName);
            assertTrue(!xDirName.endsWith(File.separator));
            assertTrue(!xDirName.endsWith("/")); 
            assertEquals(xDirName, edsa.getName(dirName));
            this.checkProperties(edsa, xDirName, true);
            for (int j=0; j < l; j++) 
            {
                String fileName  = NAMES[j];
                String xFileName = edsa.createEntry(dirName, fileName, getInputStream());
                this.checkProperties(edsa, xFileName, false);
                assertTrue(edsa.isEntry     (xFileName));
                assertTrue(!edsa.isContainer(xFileName));

                assertEquals(fileName,  edsa.getName  (xFileName));
                assertEquals(xDirName,  edsa.getParent(xFileName));

                assertTrue(edsa.isEntry     (xFileName));
                assertTrue(!edsa.isContainer(xFileName));
                assertEquals(fileName,  edsa.getName (xFileName));
                assertEquals(xDirName,  edsa.getParent(xFileName));

                assertEquals(xFileName, edsa.getChild(xDirName,fileName));
                
                assertTrue(edsa.exists(xFileName));
                
                String tmpName    = edsa.createNewEntryName(xDirName, "xxx", null);
                String tmpPath    = xDirName + '/' + tmpName;
                edsa.rename(xFileName, tmpName);
                assertTrue(!edsa.exists(xFileName));
                assertTrue(edsa.exists(tmpPath));
                assertTrue(!tmpName.equals(edsa.createNewEntryName(xDirName, "xxx", null)));
                edsa.rename(tmpPath, fileName);
                assertTrue(edsa.exists(xFileName));
                
                // What is the expected format for this value ???
                // String url = fdsa.getURL(xFileName);
            }
            assertTrue(dirName + " must exists"      , edsa.exists      (dirName));
            assertTrue(dirName + " must be conatiner", edsa.isContainer (dirName));
            assertTrue(dirName + " must not be Entry",!edsa.isEntry    (dirName));
            
            // What is the expected format for this value ???
            // url = fdsa.getURL(dirName);
            
            String entries[] = edsa.getEntryNames(dirName);
            assertEquals(l , entries.length);
            for (int j=0; j < l; j++) {
                String entryName = edsa.getName (entries[j]);
                assertTrue(entryName + " not found ", NAMESL.contains(entryName));
            }
        }
        
        // Delete all the directories again
        edsa.deleteRecursively("");
        for (int i=0; i < l; i++) {
            String dirName  = NAMES[i];
            assertTrue(!edsa.exists (dirName));
        }
    }
    
    /**
     * Test if all Sorts of Events are generated.
     */
    public void testEvents () throws Exception {
		FilesystemDataSourceAdaptor fdsa = new FilesystemDataSourceAdaptor(TEST_HOME);
        // Setup EncryptedDataSourceAdaptor via normal CTor
        EncryptedDataSourceAdaptor edsa = 
            new EncryptedDataSourceAdaptor(fdsa);
        edsa.setProtocol("TestEncryptedDataSourceAdaptor");
        
        edsa.setProtocol("e");
        edsa.addDataChangeListener(this);
        DataChangeEvent le;
        
        events = new Stack();   // Start Tracking Events
        
        edsa.createEntry("", "anEntry", getInputStream());
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_CREATED  , le.getChangeMode());
        assertEquals("e://anEntry"                  , le.getMessage());

        edsa.putEntry("anEntry", getInputStream());
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_MODIFIED , le.getChangeMode());
        assertEquals("e://anEntry"                  , le.getMessage());

        edsa.getEntryOutputStream("anEntry").close();
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_MODIFIED , le.getChangeMode());
        assertEquals("e://anEntry"                  , le.getMessage());

        edsa.delete("anEntry", NOFORCE);
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_DELETED  , le.getChangeMode());
        assertEquals("e://anEntry"                  , le.getMessage());
        
        edsa.createEntry("", "anEntry", getInputStream());
        getLastEvent();

        edsa.deleteRecursively("anEntry");
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_DELETED  , le.getChangeMode());
        assertEquals("e://anEntry"                  , le.getMessage());

        edsa.createContainer("", "aDir");
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_CREATED  , le.getChangeMode());
        assertEquals("e://aDir"                         , le.getMessage());
        
        edsa.delete("aDir", NOFORCE);
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_DELETED,  le.getChangeMode());
        assertEquals("e://aDir",            le.getMessage());

        edsa.createContainer("", "aDir");
        getLastEvent();
        edsa.createEntry("aDir", "anEntry", getInputStream());
        getLastEvent();

        edsa.deleteRecursively("aDir");
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_DELETEDREC   , le.getChangeMode());
        assertEquals("e://aDir"                             , le.getMessage());
        
        edsa.removeDataChangeListener(this);
    
        events = null;   // Stop Tracking Events
    }

    /**
     * Test if Operations are correctly suppressed by Eventhandlers
     */
    public void testDisAllow() throws Exception {
		FilesystemDataSourceAdaptor fdsa = new FilesystemDataSourceAdaptor(TEST_HOME);
        // Setup EncryptedDataSourceAdaptor via normal CTor
        EncryptedDataSourceAdaptor edsa = 
            new EncryptedDataSourceAdaptor(fdsa);
        edsa.setProtocol("TestEncryptedDataSourceAdaptor");
        try {
            edsa.addDataChangeListener(this);
            
            allow = false;
            try {
                edsa.createEntry("", "anEntry", getInputStream());
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }
            
            try {
                edsa.createEntry("", "anEntry").close();
                fail("This is not allowed");
            } catch (DataChangeException expected) {/* expected */ }
            
            allow = true;
            edsa.createEntry("", "anEntry", getInputStream());
            allow = false;

            try {
                edsa.putEntry("anEntry", getInputStream());
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            try {
                edsa.getEntryOutputStream("anEntry").close();
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            try {
                edsa.delete("anEntry", NOFORCE);
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            try {
                edsa.deleteRecursively("anEntry");
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            allow = true;
            edsa.delete("anEntry", NOFORCE);
            allow = false;

            try {
                edsa.createContainer("", "aDir");
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }
            
            allow = true;
            edsa.createContainer("", "aDir");
            allow = false;

            try {
                edsa.deleteRecursively("aDir");
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            allow = true;
            edsa.deleteRecursively("aDir");

            edsa.removeDataChangeListener(this);
        }
        finally {
            allow = true; // dont let this accidently stick to false.
        }
    }
    
   /**
    * Check all properties of DAPropertyNames, check for consistence
    */
   private void checkProperties(DataSourceAdaptor aDSA, String aName, boolean isContainerCheck) throws DatabaseAccessException{
      
       Object theAttribute;
       DataObject theDataObject = aDSA.getProperties(aName);
       
       checkProperty (theDataObject, DAPropertyNames.SIZE         , Long.class);
       checkProperty (theDataObject, DAPropertyNames.LAST_MODIFIED, Long.class);
       checkProperty (theDataObject, DAPropertyNames.IS_READABLE  , Boolean.class);
       checkProperty (theDataObject, DAPropertyNames.IS_WRITEABLE , Boolean.class);
       theAttribute = checkProperty (theDataObject, DAPropertyNames.IS_ENTRY, Boolean.class);
       if (theAttribute != null && theAttribute instanceof Boolean){
            boolean theBool = ((Boolean)theAttribute).booleanValue();
            assertEquals(!isContainerCheck , theBool);
       }
       theAttribute = checkProperty (theDataObject, DAPropertyNames.IS_CONTAINER, Boolean.class);
       if (theAttribute != null && theAttribute instanceof Boolean){
          boolean theBool = ((Boolean)theAttribute).booleanValue();
          assertEquals(isContainerCheck, theBool);
       }
       theAttribute = checkProperty (theDataObject, DAPropertyNames.EXISTS, Boolean.class);
       if (theAttribute != null && theAttribute instanceof Boolean){
           boolean theBool = ((Boolean)theAttribute).booleanValue();
           assertTrue(theBool);
       }
       theAttribute = checkProperty (theDataObject, DAPropertyNames.NAME, String.class);
        
       checkProperty (theDataObject, DAPropertyNames.NUM_VERSIONS, Integer.class);
       theAttribute = checkProperty (theDataObject, DAPropertyNames.LOCKED, Boolean.class);
       if (theAttribute != null && theAttribute instanceof Boolean){
          boolean theBool = ((Boolean)theAttribute).booleanValue();
          if (theBool){
            checkProperty (theDataObject, DAPropertyNames.LOCKER, String.class);
          }
       }
       theAttribute = checkProperty (theDataObject, DAPropertyNames.DELETED, Boolean.class);
       if (theAttribute != null && theAttribute instanceof Boolean){
            boolean theBool = ((Boolean)theAttribute).booleanValue();
            assertTrue(!theBool);
       }
       checkProperty (theDataObject, DAPropertyNames.AUTHOR, String.class);    
   }

    /**
     * check whether <code>getAttribute()</code> returns the expected type.
     * 
     * @return the Object retrieved, for further testing.
     */
    private Object checkProperty(DataObject aDataObject, String anAttributeName,
                                 Class anExpectedClass) {
        Object theAttribute = null;
        try {
            theAttribute = aDataObject.getAttributeValue(anAttributeName);
            if (theAttribute != null) {
                assertTrue(
                    theAttribute.getClass().isAssignableFrom(anExpectedClass));
            }
            else {
                System.out.println("Attribute " + anAttributeName + "is null");
            }
        }
        catch (NoSuchAttributeException ignored) {/* ignored */}

        return theAttribute;

    }
    
    // Static methodes

    /**
     * the suite of tests to execute.
     */
    public static Test suite () {
        
        TestSuite suite = new TestSuite ();
        
        suite.addTest(new TestEncryptedDataSourceAdaptor("cleanupTmp"));
        suite.addTestSuite(TestEncryptedDataSourceAdaptor.class);
        
        // Test suite = new TestEncryptedDataSourceAdaptor("testDisAllow");

        return DSATestSetup.createDSATestSetup(ServiceTestSetup.createSetup(suite, EncryptionService.Module.INSTANCE));
    }

}
