<p>Technically, the layout editor offers such components for which templates are available. Such a layout template is a file <code class="hljs inlineCode">*.template.xml</code> in the folder <code class="hljs inlineCode">WEB-INF/layouts</code> of the running application. A template can either be provided by the application itself, or by a TopLogic module.</p>
<h2>Structure of a layout template</h2>
<p>A layout template is an XML file in the namespace <code class="hljs inlineCode">http://www.top-logic.com/ns/config/6.0</code> with the root tag <code class="hljs inlineCode">template</code>:</p>
<pre><code class="language-xml">&lt;config:template
  xmlns:config="http://www.top-logic.com/ns/config/6.0"
  groups="..."
&gt;
  &lt;properties extends="..."&gt;
    &lt;property name="myProp"
      type="..."
    &gt;
      ...
    &lt;/property&gt;

    ...
  &lt;/properties&gt;

  &lt;component name="..." 
    class="..."
    option="${myProp}"
  &gt;
    ...
  &lt;/component&gt;
&lt;/config:template&gt;</code></pre>
<div>
 <div>
  The file consists of two sections. The <code class="hljs inlineCode">properties</code> header defines the options provided by the layout editor (<code class="hljs inlineCode">property</code>). The next (and only) element after the <code class="hljs inlineCode">properties</code> section is the component configuration to be generated by the template. The configuration options of the configured component can refer to the value of the property named <code class="hljs inlineCode">myProp</code> via <code class="hljs inlineCode">${myProp}</code>. </div>
</div>
<p>A property of a layout template behaves like a property of the <a class="tlObject" data-custom="true" href="?page=TypedConfiguration&amp;uuid=5122a416-bd1c-445b-83a9-8c88e26004dc">typed configuration</a>, which is defined instead of over the Getter of a Java interface in XML. The name of the property is given in the attribute <code class="hljs inlineCode">name</code>. The type of the property is specified either directly in the <code class="hljs inlineCode">type</code> attribute as a fully qualified class name if it is a primitive property. If it is a list-valued property, the <code class="hljs inlineCode">type</code> is equal to <code class="hljs inlineCode">List</code> and the list value type is given in <code class="hljs inlineCode">element-type</code>. If it is an instance subconfiguration, the <code class="hljs inlineCode">type</code> or <code class="hljs inlineCode">element-type</code> is equal to <code class="hljs inlineCode">PolymorphicConfiguration</code> and the type of the configured instance is given by <code class="hljs inlineCode">instance-type</code>. Examples of properties are:</p>
<p>A simple Boolean property "<code class="hljs inlineCode">tabVisible</code>" (the default value can be given via the <code class="hljs inlineCode">default</code> attribute):</p>
<pre><code class="language-xml">&lt;property name="tabVisible"
  default="true"
  type="boolean"
/&gt;
</code></pre>
<p>An instance configuration of a model builder (annotations to the property can be given in the content area of the property):</p>
<pre><code class="language-xml">&lt;property name="modelBuilder"
  instance-type="com.top_logic.mig.html.ListModelBuilder"
  type="PolymorphicConfiguration"
&gt;
  &lt;mandatory/&gt;
  &lt;options fun="com.top_logic.layout.form.values.edit.AllInAppImplementations"/&gt;
&lt;/property&gt;
</code></pre>
<p>A list of button instance configurations:</p>
<pre><code class="language-xml">&lt;property name="buttons"
  element-type="com.top_logic.basic.config.PolymorphicConfiguration"
  instance-type="com.top_logic.tool.boundsec.CommandHandler"
  type="List"
&gt;
  &lt;acceptable-classifiers value="commons, dialog"/&gt;
&lt;/property&gt;
</code></pre>
<h2>Wizard templates</h2>
<p>Normal templates expect the same set of options for the creation of a new component as for the subsequent editing of an already created component. However, sometimes it is useful to request only a small set of initial values when creating a new component and use them to fill the parameters of the actual template with meaningful default values. Thus from the input of a type a good default value for various lookup and test functions of a model builder can be generated.</p>
<p>In order to simplify the component generation in such a way, there are assistant templates, which call another template with few initial parameters to be filled and occupy the "real" parameters from the entered values. If a component created via a wizard template is edited later, the complete parameters of the actual template are then offered for editing. The following template is a wizard for the actual template <code class="hljs inlineCode">my-real-component.template.xml</code>, which is specified in the <code class="hljs inlineCode">assistant-for</code> attribute. In the content area of a wizard template, no component configuration is created, but the configuration of the parameters of the target template (<code class="hljs inlineCode">config</code>):</p>
<pre><code class="language-xml">&lt;config:template
  xmlns:config="http://www.top-logic.com/ns/config/6.0"
  assistant-for="my-real-component.template.xml"
&gt;
  &lt;properties&gt;
    &lt;property name="initProp" type="String"&gt;
    ...
  &lt;/properties&gt;

  &lt;config&gt;
    &lt;realProp&gt;${initProp}&lt;/realProp&gt;
  &lt;/config&gt;
&lt;/config:template&gt;</code></pre>
<div>
 <div>
  <h2>View templates</h2>
  <p>A template can create not only a single component, but a whole view consisting of several simultaneously displayed components, dialogs and buttons. For this, a template can call other templates via <code class="hljs inlineCode">temlate-call</code>. To a <code class="hljs inlineCode">template-call</code> one passes the template to be instantiated with the <code class="hljs inlineCode">template</code>-attribute and in the content area the arguments for the parameters of this template with the <code class="hljs inlineCode">arguments</code>-element. If you turn a view template into a wizard template (see above), this has the positive side effect that the template calls become independently configurable components. I.e. after creating a view with a view wizard, several components are created that can be further processed independently of each other. The properties of each of these components can then be adjusted in the layout editor.</p>
  <p>The following view wizard creates three components: A table next to a form and a Create dialog at the table:</p>
  <pre><code class="language-xml">&lt;config:template
  xmlns:config="http://www.top-logic.com/ns/config/6.0"
  assistant-for="com.top_logic/layout.template.xml"
&gt;
  &lt;properties extends="com.top_logic.layout.editor.config.TypeTemplateParameters"&gt;
    ...
  &lt;/properties&gt;

  &lt;config&gt;
    &lt;components&gt;
      &lt;config:template-call
        layout-scope="__tableTemplateScope__"
        template="com.top_logic/table.template.xml"
      &gt;
        &lt;arguments name="..."
          type="..."
        &gt;
          &lt;dialogs&gt;
            &lt;config:template-call template=".../genericCreateDialog.template.xml"&gt;
              &lt;arguments&gt;
                ...
              &lt;/arguments&gt;
            &lt;/config:template-call&gt;
          &lt;/dialogs&gt;
        &lt;/arguments&gt;
      &lt;/config:template-call&gt;

      &lt;config:template-call template=".../form.template.xml"&gt;
        &lt;arguments 
          model="selection(__tableTemplateScope__#Table)"
        /&gt;
      &lt;/config:template-call&gt;
    &lt;/components&gt;
  &lt;/config&gt;
&lt;/config:template&gt;</code></pre>
  <p>A special feature here is that a link between the selection of the table and the model of the form is created at the same time. Since table and form are created after expansion of the template by two different templates and a component reference always refers to the file, in which the component is defined, this relationship cannot be formulated actually before expansion of the template yet, because the two target files, into which the templates for table and form are expanded do not exist yet.</p>
  <p>To realize this nevertheless, a variable for the target file ("layout scope") can be specified with a template call. With the declaration <code class="hljs inlineCode">layout-scope="__tableTemplateScope__"</code> at the template call for the table it is said that the target file into which this template is expanded should be named <code class="hljs inlineCode">__tableTemplateScope__</code>. This variable can then be used to refer to the table component in the model definition of the form: <code class="hljs inlineCode">selection(__tableTemplateScope__#Table)</code></p>
  <p>The scope variable <code class="hljs inlineCode">__tableTemplateScope__</code> can be used like a file name to build a component reference. With expansion of the View Wizard, this variable is consistently replaced by the filenames into which the templates are expanded.</p>
 </div>
</div>