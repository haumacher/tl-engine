<p></p>
<h1 id="VordefinierteBindingsfürstrukturierteWerte">Vordefinierte Bindings für strukturierte Werte</h1>
<h2 id="Komma-separierteString-Liste">Komma-separierte String-Liste</h2>
<pre><code>public interface Config extends ConfigurationItem {
  @Format(CommaSeparatedStrings.class)
  List&lt;String&gt; getMyListValues();
}
</code></pre>
<p>Konfigurierbar als:</p>
<pre><code>&lt;foo my-list-values="bli,bla,blub" /&gt;
</code></pre>
<p>Außer <code class="hljs inlineCode">CommaSeparatedStrings</code> gibt es noch andere, ähnliche Formate:</p>
<ul>
 <li><code class="hljs inlineCode">CommaSeparatedStringSet</code> liefert ein <code class="hljs inlineCode">Set</code> statt einer <code class="hljs inlineCode">List</code>. Dafür muss natürlich auch die Property als <code class="hljs inlineCode">Set&lt;String&gt;</code> deklariert sein.</li>
 <li><code class="hljs inlineCode">CommaSeparatedEnum</code> als abstrakte Basisklasse für Enums, siehe dazu eine der bereits existierenden Ableitungen, zB: <code class="hljs inlineCode">CommaSeparatedMonths</code></li>
</ul>
<h2 id="String-ListeüberXML-Tags">String-Liste über XML-Tags</h2>
<pre><code>public interface Config extends ConfigurationItem {
  @ListBinding()
  List&lt;String&gt; getMyListValues();
}
</code></pre>
<p>Lässt sich konfigurieren als:</p>
<pre><code>&lt;foo&gt;
  &lt;my-list-values&gt;
    &lt;my-list-value value="bli" /&gt;
    &lt;my-list-value value="bla" /&gt;
    &lt;my-list-value value="blub" /&gt;
  &lt;/my-list-values&gt;
&lt;/foo&gt;
</code></pre>
<ul>
 <li>Die Tag- und Attribut-Namen können als optionale Parameter am <code class="hljs inlineCode">@ListBinding</code> spezifiziert werden.</li>
 <li>Für andere Typen als Strings kann ein <code class="hljs inlineCode">ConfigurationValueProvider</code> als Parameter am <code class="hljs inlineCode">@ListBinding</code> angegeben werden.</li>
</ul>
<p>Der Default-Wert ist in beiden Fällen eine leere, modifizierbare und größenveränderbare Liste, nicht <code class="hljs inlineCode">null</code>.</p>
<h2 id="MapmitprimitivemKeyundWert">Map mit primitivem Key und Wert</h2>
<pre><code>public interface Config extends ConfigurationItem {
  @MapBinding()
  Map&lt;String, String&gt; getAdditionalNamespaces();
}
</code></pre>
<p>Lässt sich konfigurieren als:</p>
<pre><code>&lt;foo&gt;
  &lt;additional-namespaces&gt;
    &lt;additional-namespace key="config" value="http://www.top-logic.com/ns/config/6.0"/&gt;
    &lt;additional-namespace key="annotation" value="http://www.top-logic.com/ns/layout/annotation/1.0"/&gt;
    &lt;additional-namespace key="fubar" value="http://example.com/NS/fubar"/&gt;
  &lt;/additional-namespaces&gt;
&lt;/foo&gt;
</code></pre>
<p>Die Tag- und Attribut-Namen können als optionale Parameter am <code class="hljs inlineCode">@MapBinding</code> spezifiziert werden:</p>
<pre><code>public interface Config extends ConfigurationItem {
  @MapBinding(tag = "namespace", key = "prefix", attribute = "uri")
  Map&lt;String, String&gt; getAdditionalNamespaces();
}
</code></pre>
<p>In diesem Fall muss die Konfiguration folgendermaßen lauten:</p>
<pre><code>&lt;foo&gt;
  &lt;additional-namespaces&gt;
    &lt;namespace prefix="config" uri="http://www.top-logic.com/ns/config/6.0"/&gt;
    &lt;namespace prefix="annotation" uri="http://www.top-logic.com/ns/layout/annotation/1.0"/&gt;
    &lt;namespace prefix="fubar" uri="http://example.com/NS/fubar"/&gt;
  &lt;/additional-namespaces&gt;
&lt;/foo&gt;
</code></pre>
<p>Für andere Typen als Strings kann jeweils ein <code class="hljs inlineCode">ConfigurationValueProvider</code> für den Key und den Value angegeben werden:</p>
<pre><code>public interface Config extends ConfigurationItem {
  @MapBinding(keyFormat = ClassReferenceResolver.class, valueFormat = HexEncodedColor.class)
  Map&lt;Class, Color&gt; getAdditionalNamespaces();
}
</code></pre>
<p>Der Default-Wert ist eine leere, modifizierbare Map, nicht <code class="hljs inlineCode">null</code>.</p>