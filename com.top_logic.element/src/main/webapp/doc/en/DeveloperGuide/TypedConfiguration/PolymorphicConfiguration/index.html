<p></p>
<h1 id="Instanzkonfiguration">Instanzkonfiguration</h1>
<p>Neben reinen Konfigurationen gibt es den häufig angewendenten Spezialfall der Instanzkonfiguration. Eine Instanzkonfiguration dient dazu, eine konfigurierbare Komponente zu instanziieren.</p>
<p>Eine Instanzkonfigurationen werden statt von <code class="hljs inlineCode">ConfigurationItem</code> von <code class="hljs inlineCode">PolymorphicConfiguration</code> abgeleitet. Sie hat ein ausgezeichnetes Konfigurationsproperty <code class="hljs inlineCode">class</code> (vgl. <code class="hljs inlineCode">PolymorphicConfiguration#getImplementationClass()</code>). Dieses spezielle Property hat zwei Funktionen:</p>
<ul>
 <li>In der Konfiguration wird darüber die Implementierungsklasse angegeben, welche mit der entsprechenden Konfiguration gebaut werden soll.</li>
 <li>Die angegebene Implementierungsklasse bestimmt über ihren Konfigurationskonstruktor das konkrete Konfigurations(sub)interface, welches verwendet werden muss. Implizit wählt damit die Implementierungsklasse den Konfigurationstyp, mit dem sie konfiguriert werden kann.</li>
</ul>
<p>Im folgenden Beispiel deklariert eine abstrakte konfigurierbare Komponente <code class="hljs inlineCode">Component</code> ein Konfigurationsinterface <code class="hljs inlineCode">Component.Config</code>, und referenziert dieses in ihrem Konfigurationskonstruktor. Für den Komponentennamen und den Namen des Konfigurationsinterfaces gibt es keine Einschränkungen.</p>
<pre><code>public abstract class Component {
   public interface Config extends PolymorphicConfiguration&lt;Component&gt; {
      int getOption();
   }

   /** Konfigurationskonstruktor */
   Component(InstantiationContext context, Config config) {
      ...
   }
}
</code></pre>
<p>Die konkrete Ableitung <code class="hljs inlineCode">MyComponent1</code> verwendet dieselben (geerbten) Konfigurationsoptionen (liefert lediglich einen Implementierungsanteil):</p>
<pre><code>public class MyComponent1 extends Component {
   MyComponent1(InstantiationContext context, Config config) {
      ...
   }
}
</code></pre>
<p>Eine Instanz von <code class="hljs inlineCode">MyComponent1</code> kann durch Angabe der Implementierungsklasse und ihrer Konfigurationoptionen konfiguriert werden:</p>
<pre><code>&lt;component class="my.package.MyComponent1"
   option="42"
/&gt;
</code></pre>
<p><code class="hljs inlineCode">MyComponent2</code> deklariert ein spezialisiertes Konfigurationsinterface und erlaubt damit neben der Konfigurationsoption <code class="hljs inlineCode">option</code> aus <code class="hljs inlineCode">Component</code> die zusätzliche Option <code class="hljs inlineCode">other-option</code>:</p>
<pre><code>public class MyComponent2 extends Component {
   public interface Config extends Component.Config {
      String getOtherOption();
   }

   MyComponent2(InstantiationContext context, Config config) {
      ...
   }
}
</code></pre>
<p>In der Konfiguration einer Instanz von <code class="hljs inlineCode">MyComponent2</code> ist damit implizit die Angabe eines Wertes für die spezialisierte Konfigurationsoption <code class="hljs inlineCode">other-config</code> möglich:</p>
<pre><code>&lt;component class="my.package.MyComponent2"
   option="42"
   otherOption="Hello World!"
/&gt;
</code></pre>
<p>Die Kombination der Implementierungsklasse <code class="hljs inlineCode">MyComponent1</code> mit der Konfigurationsoption <code class="hljs inlineCode">other-option</code> würde als Konfiguationsfehler erkannt werden.</p>
<h2 id="Komponentenkonstruktor">Komponentenkonstruktor</h2>
<p>Damit eine Komponente <code class="hljs inlineCode">Component</code> vom Framework instanziiert werden kann, benötigt sie einen Konstruktor mit der Signatur <code class="hljs inlineCode">Component(InstantiationContext, Component.Config)</code>. Die Aufgabe des Komponentenkonstruktors ist es, die Konfiguration in der Komponente zu speichern und eventuell Subkomponenten zu instanziieren. Die Konfiguration wird mit dem für die Komponente speziellen Konfigurationsinterface <code class="hljs inlineCode">Component.Config</code> (nicht mit dem Wurzelinterface <code class="hljs inlineCode">ConfigurationItem</code>) deklariert. Über die Signatur des Komponentenkonstruktors ist es über Reflection möglich, für eine gegebene Komponentenklasse auf das für sie spezielle Konfigurationsinterface und damit auf die für sie zulässigen Konfigurationseigenschaften zu schließen.</p>
<p>Eine konfigurierbare Klasse:</p>
<pre><code>public class Foo&lt;C extends Foo.Config&lt;?&gt;&gt; implements ConfiguredInstance&lt;C&gt; {

  public interface Config&lt;I extends Foo&lt;?&gt;&gt; extends PolymorphicConfiguration&lt;I&gt; {
    ...
  }

  private final C _config;

  public Foo(InstantiationContext context, C config) {
    _config = config;
   ...
  }

  @Override
  public C getConfig() {
    return _config;
  }

}
</code></pre>
<ul>
 <li>*Wichtig:<strong> Damit die Instanziierung nicht scheitert, muss folgendes beachtet werden: </strong></li>
 <li>Die Klasse muss <code class="hljs inlineCode">public</code> deklariert sein.</li>
 <li>Das Config-Interface muss <code class="hljs inlineCode">public</code> sein.</li>
 <li>Der Config-Konstruktor muss <code class="hljs inlineCode">public</code> sein.</li>
 <li>Das Config-Interface muss von <code class="hljs inlineCode">PolymorphicConfiguration</code> erben.</li>
 <li>Die Klasse sollte <code class="hljs inlineCode">ConfiguredInstance</code> implementieren. Das ist für verschiedene weitergehende Features notwendig, für die Instanziierung an sich aber nicht. Statt <code class="hljs inlineCode">ConfiguredInstance</code> direkt zu implementieren, kann als Basisklasse <code class="hljs inlineCode">AbstractConfiguredInstance</code> verwendet werden.</li>
</ul>
<p>Eine Ableitung einer solchen Klasse muss folgendermaßen aussehen:</p>
<pre><code>public class Bar&lt;C extends Bar.Config&lt;?&gt;&gt; extends Foo&lt;C&gt; {

  public interface Config&lt;I extends Bar&lt;?&gt;&gt; extends Foo.Config&lt;I&gt; {
    ...
  }

  public Bar(InstantiationContext context, C config) {
    super(context, config);
   ...
  }

}
</code></pre>
<p><strong>Wichtig:</strong> Der Config-Constructor darf nicht direkt aufgerufen werden. Er darf ausschließlich vom <code class="hljs inlineCode">InstantiationContext</code> aufgerufen werden:</p>
<pre><code>PolymorphicConfiguration&lt;Foo&gt; myConfig = ...;
InstantiationContext context = new DefaultInstantiationContext(...);
Foo myInstance = context.getInstance(myConfig);
</code></pre>
<h2 id="Subkomponenten">Subkomponenten</h2>
<h3 id="BenannteSubkomponenten">Benannte Subkomponenten</h3>
<pre><code>public class A {
   public interface Config extends PolymorphicConfiguration&lt;A&gt; {
      B.Config getBConfig();
   }

   B b;

   public A(InstantiationContext context, A.Config config) {
      this.b = (B) context.getInstance(config.getBConfig());
   }
}

public class B {
   public interface Config extends PolymorphicConfiguration&lt;B&gt; {
      ...
   }

   public B(InstantiationContext context, B.Config config) {
      ...
   }
}
</code></pre>
<p>In obigem Beispiel enthält die Konfiguration der Komponente <code class="hljs inlineCode">A</code> eine Referenz auf eine Konfiguration für eine Komponente <code class="hljs inlineCode">B</code> (<code class="hljs inlineCode">B.Config</code>). Die Komponente <code class="hljs inlineCode">A</code> selbst benötigt für ihre Instanziierung aber eine Referenz auf eine Subcomponente <code class="hljs inlineCode">B</code>. Die Auflösung von "Konfiguration von <code class="hljs inlineCode">B</code>" (<code class="hljs inlineCode">B.Config</code>) zu einer Referenz auf die konfigurierte Subkomponente <code class="hljs inlineCode">B</code> erfolgt über den Instanziierungskontext <code class="hljs inlineCode">InstantiationContext</code>. Der Instanziierungskontext entscheidet darüber, ob eine neue Instanz von <code class="hljs inlineCode">B</code> angelegt werden muss, oder ob eine bereits erzeugte Instanz von <code class="hljs inlineCode">B</code> mit derselben Konfiguration bereits existiert und wiederverwendet werden kann (siehe <a href="MehrfachverwendungvonKomponenten">Mehrfachverwendung von Komponenten</a>).</p>
<h3 id="ListenvonSubkomponenten">Listen von Subkomponenten</h3>
<p>Benötigt eine Komponente <code class="hljs inlineCode">A</code> eine Liste von Subkomponenten <code class="hljs inlineCode">B</code>, so wird einfach eine typisiert Get-Methode <code class="hljs inlineCode">List&lt;B.Config&gt; getBConfigs</code> definiert. Die Annotation <code class="hljs inlineCode">com.top_logic.basic.config.annotation.EntryTag</code> gibt an wie das Tag der einzelnen Listeneinträge heißt.</p>
<pre><code>public class A {
   public interface Config extends PolymorphicConfiguration&lt;A&gt; {

      @EntryTag("bConfig")
      List&lt;B.Config&gt;getBConfigs();
   }

   List&lt;B&gt; bs;

   public A(InstantiationContext context, A.Config config) {
      this.bs = TypedConfiguration.getInstanceList(context, config.getBConfigs());
   }
}
</code></pre>
<p>Bei der Instanziierung von <code class="hljs inlineCode">A</code> wird die Liste von <code class="hljs inlineCode">B.Config</code> Elementen zu einer Liste von Komponenten <code class="hljs inlineCode">B</code> aufgelöst.</p>
<h3 id="IndizierteSubkomponenten">Indizierte Subkomponenten</h3>
<pre><code>public class A {
   public interface Config extends PolymorphicConfiguration&lt;A&gt; {

      @Key(B.Config.NAME_PROPERTY_NAME)
      @EntryTag("bConfig")
      Map&lt;String, B.Config&gt; getBConfigs();
   }

   Map&lt;String, B&gt; bs;

   public A(InstantiationContext context, A.Config config) {
      this.bs = TypedConfiguration.getInstanceMap(context, config.getBConfigs());
   }
}

public class B {
   public interface Config extends PolymorphicConfiguration&lt;B&gt; {

      String NAME_PROPERTY_NAME = "name";

      @Name(NAME_PROPERTY_NAME)
      String getName()
   }

   ...
}
</code></pre>
<p>Eine Komponente <code class="hljs inlineCode">A</code> kann eine Ansammlung von Subkomponenten enthalten, die nach einem definierten Konfigurationswert indiziert werden. In der obigen Deklaration besteht die Konfiguration <code class="hljs inlineCode">A.Config</code> aus einer indizierten Ansammlung von Konfigurationen <code class="hljs inlineCode">B.Config</code>, die nach dem Konfigurationswert <code class="hljs inlineCode">B.Config.getName()</code> indiziert sind. Die von <code class="hljs inlineCode">A.Config.getBConfigs()</code> gelieferte Map enthält als Werte Konfigurationseinträge <code class="hljs inlineCode">B.Config</code> und als Schlüssel die Werte der Property <code class="hljs inlineCode">name</code> der entsrechenden <code class="hljs inlineCode">B.Config</code> Konfigurationseinträge.</p>
<p>Über die Annotation <code class="hljs inlineCode">com.top_logic.basic.config.annotation.Key</code> wird deklariert, dass die Ansammlung nach der Eigenschaft <code class="hljs inlineCode">name</code> des Elementtyps <code class="hljs inlineCode">B.Config</code> indiziert werden soll. Die Referenz auf eine Eigenschaft eines Konfigurationsinterfaces wird realisiert, indem der <a href="Konfigurationsnamen">Konfigurationsname</a> der fremden Eigenschaft angegeben wird.</p>
<p>Bei Verwendung des <a href="Default-XML-Binding">Default-XML-Bindings</a> könnte eine Komponente über folgendes XML-Document konfiguriert werden:</p>
<pre><code>&lt;aConfig&gt;
   &lt;bConfigs&gt;
      &lt;bConfig name="component-1" /&gt;
      &lt;bConfig name="component-2" /&gt;
      &lt;bConfig name="component-3" /&gt;
      ...
   &lt;bConfigs&gt;
&lt;/aConfig&gt;
</code></pre>
<p>Das Ergebnis von <code class="hljs inlineCode">A.Config.getBConfigs()</code> wäre dann eine Map, welche die im <code class="hljs inlineCode">name</code>-Attribute angegebenen Schlüssel <code class="hljs inlineCode">component-1</code>,… auf den jeweiligen Konfigurationseintrag vom Typ <code class="hljs inlineCode">B.Config</code> abbildet.</p>
<p>Bei der Instanziierung bleiben die Map-Schlüssel erhalten, und die Konfigurationseinträge werden durch die jeweiligen konfigurierten Instanzen ersetzt.</p>
<p>Auch Eigenschaften vom Typ <code class="hljs inlineCode">Collection</code>, <code class="hljs inlineCode">List</code> und <code class="hljs inlineCode">Set</code> können mit der <code class="hljs inlineCode">@Key</code>-Annotation versehen werden. In diesem Fall, können in einer inkrementellen XML-Konfiguration auf einzelne Elemente der Kollektion zugegriffen werden, siehe unten.</p>
<h2 id="MehrfachverwendungvonKomponenten">Mehrfachverwendung von Komponenten</h2>
<p>Eine Komponente, die neben ihrer (unveränderlichen) Konfiguration keinen weiteren dynamischen Zustand besitzt kann innerhalb einer Komponentenstruktur dann mehrfach verwendet werden, wenn ihre Konfiguration identisch ist. Beispiele hierfür sind konfigurierbare Control-Provider, Renderer, Resource-Provider, Label-Provider.</p>
<p>Im Normalfall erzeugt der <code class="hljs inlineCode">InstantiationContext</code> für eine gegebene Konfiguration in <code class="hljs inlineCode">getInstance(ConfigurationItem)</code> immer eine neue konfigurierte Komponente. Ist die Komponentenimplementierung allerdings als <code class="hljs inlineCode">@SharedInstance</code> annotiert, werden pro Instanziierungslauf dann dieselben Komponentenimplementierungen geliefert, wenn ihre Konfiguration übereinstimmt.</p>
<p>Die <code class="hljs inlineCode">@SharedInstance</code> Annotation wird an der konkreten Komponentenimplementierungsklasse vorgenommen. Die Annotation wird nicht vererbt, so dass jede Unterklasse einer "shared" Komponente die Annotation wiederholen muss, wenn sie keinen dynamischen Zustand zu ihrer Implementierung hinzufügt.</p>