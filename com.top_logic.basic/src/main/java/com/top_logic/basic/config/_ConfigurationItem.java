/*
 * SPDX-FileCopyrightText: 2017 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.basic.config;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.top_logic.basic.Log;
import com.top_logic.basic.NamedConstant;
import com.top_logic.basic.annotation.FrameworkInternal;
import com.top_logic.basic.config.ConfigurationChange.Kind;
import com.top_logic.basic.config.container.ConfigPart;
import com.top_logic.basic.config.container.ConfigPartInternal;
import com.top_logic.basic.config.container.ConfigPartUtilInternal;
import com.top_logic.basic.config.equal.ConfigEquality;
import com.top_logic.basic.config.equal.EqualityByValue;
import com.top_logic.basic.config.internal.ItemChangeHandler;
import com.top_logic.basic.config.internal.gen.ConfigItemGenerator;
import com.top_logic.basic.util.Utils;

/**
 * Base class for {@link ConfigurationItem} implementations generated by the
 * {@link ConfigItemGenerator}.
 *
 * @author <a href="mailto:daniel.busche@top-logic.com">Daniel Busche</a>
 */
@FrameworkInternal
public class _ConfigurationItem implements ConfigurationItem, ItemChangeHandler {

	/**
	 * Switch constant for property {@link #_getConfigurationInterface()}.
	 */
	protected static final int _CONFIGURATION_INTERFACE__IDX = 0;

	private static final PropertyDescriptor _CONFIGURATION_INTERFACE__PRP;

	/**
	 * Index of switch constants for all properties.
	 */
	protected static final Map<NamedConstant, Integer> _INDEX;

	private static final NamedConstant ALL = new NamedConstant("*");

	static {
		ConfigurationDescriptor descriptor = TypedConfiguration.getConfigurationDescriptor(ConfigurationItem.class);
		_CONFIGURATION_INTERFACE__PRP = descriptor.getProperty(CONFIGURATION_INTERFACE_NAME);

		Map<NamedConstant, Integer> index = new HashMap<>();
		__index(index, _CONFIGURATION_INTERFACE__PRP, _CONFIGURATION_INTERFACE__IDX);

		_INDEX = index;
	}

	private final ConfigurationDescriptor _descriptor;

	private final Location _location;

	private ConfigurationItem _container = null;

	/**
	 * Note: Listeners are indexed by property name instead of by property descriptor to save a hash
	 * lookup during set, if no listeners are registered.
	 */
	private Map<NamedConstant, ListenerList> _listenersByProperty;

	/**
	 * @see #__lookup(Map, PropertyDescriptor)
	 */
	protected static final int __NO_SUCH_PROPERTY = -1;

	/**
	 * Creates an empty {@link _ConfigurationItem}.
	 *
	 * @param descriptor
	 *        See {@link #descriptor()}.
	 * @param location
	 *        See {@link #location()}.
	 */
	public _ConfigurationItem(ConfigurationDescriptor descriptor, Location location) {
		_descriptor = descriptor;
		_location = location;
	}
	
	/**
	 * Creates a {@link _ConfigurationItem} with values taken from the given
	 * {@link ConfigurationItem}.
	 *
	 * @param descriptor
	 *        See {@link #descriptor()}.
	 * @param other
	 *        The {@link ConfigurationItem} to take the values from.
	 */
	public _ConfigurationItem(ConfigurationDescriptor descriptor, ConfigurationItem other) {
		_descriptor = descriptor;
		_location = other.location();
	}

	@Override
	public ConfigurationDescriptor descriptor() {
		return _descriptor;
	}

	@Override
	public Location location() {
		return _location;
	}

	@Override
	public Class<?> getConfigurationInterface() {
		return _getConfigurationInterface();
	}

	/**
	 * Internal getter for {@link #_getConfigurationInterface()}.
	 */
	protected final Class<?> _getConfigurationInterface() {
		return descriptor().getConfigurationInterface();
	}

	/**
	 * {@link PropertyDescriptor} for the {@link #getConfigurationInterface()} property.
	 */
	protected PropertyDescriptor _propertyConfigurationInterface() {
		return _CONFIGURATION_INTERFACE__PRP;
	}

	/**
	 * Generic update hook for property {@link #getConfigurationInterface()}.
	 * 
	 * @param property
	 *        The {@link PropertyDescriptor} of the property updated.
	 * @param newValue
	 *        The new value given.
	 * @param isSet
	 *        Whether this is an application-level setter call.
	 * @return The old value associated with the property before.
	 */
	protected final Object _updateConfigurationInterface(PropertyDescriptor property, Object newValue, boolean isSet) {
		return _setConfigurationInterface((Class<?>) newValue);
	}

	/**
	 * Adds the given property to the given index map with the given index.
	 */
	protected static void __index(Map<NamedConstant, Integer> map, PropertyDescriptor property,
			int index) {
		Integer clash = map.put(property.identifier(), Integer.valueOf(index));
		if (clash != null) {
			throw new AssertionError(
				"Property '" + property + "' (" + index + ") already added with index " + clash + ".");
		}
	}

	/**
	 * Looks up the index of the given {@link PropertyDescriptor} in the given index map.
	 *
	 * @param indexMap
	 *        The index map used for lookup.
	 * @param property
	 *        The property to lookup.
	 * @return The found index or {@link #__NO_SUCH_PROPERTY} if not found.
	 */
	private int __lookup(Map<NamedConstant, Integer> indexMap, PropertyDescriptor property) {
		Integer index = indexMap.get(property.identifier());
		if (index == null) {
			return __NO_SUCH_PROPERTY;
		}
		return index.intValue();
	}

	/**
	 * Implementation of {@link ConfigPart#container()} without declaring the interface.
	 * 
	 * <p>
	 * This allows subclasses to implement {@link ConfigPart} without redeclaring this method.
	 * </p>
	 * 
	 * @see ConfigPart#container()
	 */
	public ConfigurationItem container() {
		return _container;
	}

	/**
	 * Initializer for the property {@link #CONFIGURATION_INTERFACE_NAME}.
	 */
	protected final void _initConfigurationInterface() {
		// No initialization required.
	}

	/**
	 * Internal setter for property {@link #CONFIGURATION_INTERFACE_NAME}
	 * 
	 * @param newValue
	 *        The new value to set.
	 * @return The previous value that was assigned to the property.
	 */
	protected final Object _setConfigurationInterface(Class<?> newValue) {
		throw new IllegalArgumentException("The configuration interface cannot be updated.");
	}

	/**
	 * Internal access to the "set-state" of the property {@link #CONFIGURATION_INTERFACE_NAME}
	 * 
	 * @return Whether the property has an explicitly assigned value.
	 */
	protected final boolean _isSetConfigurationInterface() {
		return false;
	}

	/**
	 * Access to the property index of the actual type.
	 */
	protected Map<NamedConstant, Integer> _index() {
		return _INDEX;
	}

	@Override
	public final Object value(PropertyDescriptor property) {
		return _value(property, __lookup(_index(), property));
	}

	/**
	 * Access to the property value of the property with the given index.
	 * 
	 * @see #value(PropertyDescriptor)
	 */
	protected Object _value(PropertyDescriptor property, int index) {
		switch (index) {
			case __NO_SUCH_PROPERTY: {
				return __unknown(property);
			}
			case _CONFIGURATION_INTERFACE__IDX: {
				return getConfigurationInterface();
			}
			default: {
				return _valueFallback(property, index);
			}
		}
	}

	/**
	 * Hook for generating an add-on to {@link #_value(PropertyDescriptor, int)} for a small number
	 * of additional properties.
	 *
	 * @param property
	 *        The property being accessed.
	 * @param index
	 *        The internal switch index of the property being accessed.
	 * @return See {@link #value(PropertyDescriptor)}.
	 */
	protected Object _valueFallback(PropertyDescriptor property, int index) {
		throw __missing(property, index);
	}

	@Override
	public final Object update(PropertyDescriptor property, Object newValue) {
		return _update(property, newValue, true);
	}

	final Object _update(PropertyDescriptor property, Object newValue, boolean isSet) {
		return _update(property, __lookup(_index(), property), newValue, isSet);
	}

	/**
	 * Internal generic update method implementing {@link #update(PropertyDescriptor, Object)}.
	 *
	 * @param property
	 *        The property to update.
	 * @param newValue
	 *        The new value to set.
	 * @param isSet
	 *        Whether this is an application-level setter call (or an internal initializer call).
	 * @return The old value associated with the property before.
	 */
	protected Object _update(PropertyDescriptor property, int index, Object newValue, boolean isSet) {
		switch (index) {
			case __NO_SUCH_PROPERTY: {
				throw __unknown(property);
			}
			case _CONFIGURATION_INTERFACE__IDX: {
				return _updateConfigurationInterface(property, newValue, isSet);
			}
			default: {
				return _updateFallback(property, index, newValue, isSet);
			}
		}
	}

	/**
	 * Hook for generating an add-on to {@link #_update(PropertyDescriptor, int, Object, boolean)}
	 * for a small number of additional properties.
	 *
	 * @param property
	 *        The property being accessed.
	 * @param index
	 *        The internal switch index of the property being accessed.
	 * @param newValue
	 *        The new value to set.
	 * @param isSet
	 *        Whether the operation is an application-level setter.
	 * @return See {@link #update(PropertyDescriptor, Object)}.
	 */
	protected Object _updateFallback(PropertyDescriptor property, int index, Object newValue, boolean isSet) {
		throw __missing(property, index);
	}

	@Override
	public final void reset(PropertyDescriptor property) {
		_reset(property, __lookup(_index(), property));
	}

	/**
	 * Implementation of {@link #reset(PropertyDescriptor)}.
	 *
	 * @param index
	 *        The index of the property to reset.
	 */
	protected void _reset(PropertyDescriptor property, int index) {
		switch (index) {
			case __NO_SUCH_PROPERTY: {
				throw __unknown(property);
			}
			case _CONFIGURATION_INTERFACE__IDX: {
				_initConfigurationInterface();
				return;
			}
			default: {
				_resetFallback(property, index);
				return;
			}
		}
	}

	/**
	 * Hook for generating an add-on to {@link #_reset(PropertyDescriptor, int)} for a small number
	 * of additional properties.
	 *
	 * @param property
	 *        The property being accessed.
	 * @param index
	 *        The internal switch index of the property being accessed. Whether the operation is an
	 *        application-level setter.
	 */
	protected void _resetFallback(PropertyDescriptor property, int index) {
		throw __missing(property, index);
	}

	@Override
	public final boolean valueSet(PropertyDescriptor property) {
		return _valueSet(property, __lookup(_index(), property));
	}

	/**
	 * Implementation of {@link #valueSet(PropertyDescriptor)}.
	 *
	 * @param index
	 *        The index of the property to request.
	 * @return Whether the property with the given index is explicitly set.
	 */
	protected boolean _valueSet(PropertyDescriptor property, int index) {
		switch (index) {
			case __NO_SUCH_PROPERTY: {
				// Note: All foreign properties are considered as not set. No error is thrown here.
				return false;
			}
			case _CONFIGURATION_INTERFACE__IDX: {
				return _isSetConfigurationInterface();
			}
			default: {
				return _valueSetFallback(property, index);
			}
		}
	}

	/**
	 * Hook for generating an add-on to {@link #_valueSet(PropertyDescriptor, int)} for a small
	 * number of additional properties.
	 *
	 * @param property
	 *        The property being accessed.
	 * @param index
	 *        The internal switch index of the property being accessed. Whether the operation is an
	 *        application-level setter.
	 * @return See {@link #valueSet(PropertyDescriptor)}.
	 */
	protected boolean _valueSetFallback(PropertyDescriptor property, int index) {
		throw __missing(property, index);
	}

	@Override
	public void check(Log protocol) {
		descriptor().check(protocol, this);
	}

	/**
	 * Implementation of {@link ConfigPartInternal#updateContainer(ConfigurationItem)} without
	 * declaring the interface.
	 * 
	 * Public to let subclasses implement {@link ConfigPartInternal} without redeclaring this
	 * method.
	 * 
	 * @see ConfigPartInternal#updateContainer(ConfigurationItem)
	 */
	public void updateContainer(ConfigurationItem newContainer) {
		Object oldContainer = _container;
		assert oldContainer == null || newContainer == null : "Either init or reset container, was "
			+ oldContainer + ", updated to " + newContainer + ".";
		_container = newContainer;
		notifyContainerPropertyListeners(oldContainer, newContainer);
	}

	private void notifyContainerPropertyListeners(Object oldContainer, Object newContainer) {
		// It is possible that multiple container properties exist,
		// therefore keep searching after the first container property.
		for (PropertyDescriptor property : descriptor().getProperties()) {
			if (property.hasContainerAnnotation()) {
				__notifyUpdate(property, oldContainer, newContainer);
			}
		}
	}

	@Override
	public boolean addConfigurationListener(PropertyDescriptor property, ConfigurationListener listener) {
		Map<NamedConstant, ListenerList> listenersByProperty = _listenersByProperty;
		if (listenersByProperty == null) {
			listenersByProperty = new HashMap<>();
			_listenersByProperty = listenersByProperty;
		}
		NamedConstant id = listenerId(property);
		ListenerList listeners = listenersByProperty.get(id);
		if (listeners == null) {
			listeners = new ListenerList();
			listenersByProperty.put(id, listeners);
		}
		return copyIfIterating(id, listeners).add(listener);
	}

	@Override
	public boolean removeConfigurationListener(PropertyDescriptor property, ConfigurationListener listener) {
		Map<NamedConstant, ListenerList> listenersByProperty = _listenersByProperty;
		if (listenersByProperty == null) {
			return false;
		}
		NamedConstant id = listenerId(property);
		ListenerList listeners = listenersByProperty.get(id);
		if (listeners == null) {
			return false;
		}
		return copyIfIterating(id, listeners).remove(listener);
	}

	private NamedConstant listenerId(PropertyDescriptor property) {
		if (property == null) {
			return ALL;
		}
		return property.getListenerIdentifier();
	}

	private ListenerList copyIfIterating(NamedConstant id, ListenerList listeners) {
		if (listeners.isIterating()) {
			listeners = listeners.copy();
			_listenersByProperty.put(id, listeners);
		}
		return listeners;
	}

	@Override
	public final void __notifyAdd(PropertyDescriptor property, int index, Object element) {
		ConfigPartUtilInternal.initContainer(element, this);
		
		sendEventModify(property, Kind.ADD, index, element);
	}

	@Override
	public final void __notifyRemove(PropertyDescriptor property, int index, Object element) {
		ConfigPartUtilInternal.clearContainer(element);

		sendEventModify(property, Kind.REMOVE, index, element);
	}

	@Override
	public final void __notifyUpdate(PropertyDescriptor property, Object oldValue, Object newValue) {
		if (Utils.equals(newValue, oldValue)) {
			return;
		}

		switch (property.kind()) {
			case PLAIN:
			case COMPLEX:
			case DERIVED:
			case REF: {
				sendEventSet(property, oldValue, newValue);
				break;
			}
			case ITEM: {
				if (oldValue != null) {
					ConfigPartUtilInternal.clearContainer(oldValue);
				}
				if (newValue != null) {
					ConfigPartUtilInternal.initContainer(newValue, this);
				}
				sendEventSet(property, oldValue, newValue);
				break;
			}
			case ARRAY: {
				Object[] newArray = (Object[]) newValue;
				Object[] oldArray = (Object[]) oldValue;
				if (Arrays.equals(newArray, oldArray)) {
					return;
				}
				if (oldArray != null) {
					ConfigPartUtilInternal.clearContainerArray(oldArray);
				}
				if (newArray != null) {
					ConfigPartUtilInternal.initContainerArray(newArray, this);
				}
				sendEventSet(property, oldArray, newArray);
				break;
			}
			case LIST:
			case MAP: {
				// No event.
				break;
			}
			default:
				throw PropertyKind.noSuchPropertyKind(property.kind());
		}
	}

	/**
	 * Check that the property is not derived.
	 *
	 * @param property
	 *        The property being set.
	 * @param isSet
	 *        Whether this operation is a custom setter call (not an initialization or internal
	 *        value update).
	 * 
	 * @throws UnsupportedOperationException
	 *         If the property is derived and this is an application-level setter call.
	 */
	protected final void __checkSet(PropertyDescriptor property, boolean isSet) {
		if (isSet && property.kind() == PropertyKind.DERIVED) {
			throw new UnsupportedOperationException("Derived property '" + property
				+ "' cannot be set in configuration type '" + getConfigurationInterface().getName() + "'.");
		}
	}

	/**
	 * Hook called from initializers of derived properties.
	 *
	 * @param property
	 *        The derived property to initialize in the context of this configuration item.
	 */
	protected final void __initDerived(final PropertyDescriptorImpl property) {
		initDerived(property, this);
	}

	private static void initDerived(final PropertyDescriptorImpl property, final _ConfigurationItem self) {
		AlgorithmDependency dependency = property.getDerivedDependency();
		ConfigurationListener updater = new ConfigurationListener() {
			@Override
			public void onChange(ConfigurationChange change) {
				Object newValue = property.computeDerived(self);
				self._update(property, newValue, false);
			}
		};
		dependency.installFinally(self, updater);
		updater.onChange(null);
	}

	/**
	 * Stub called from visit method definitions that have no visit case in the corresponding
	 * visitor.
	 *
	 * @param methodName
	 *        The name of the visit method being called.
	 * @throws AssertionError
	 *         Unconditionally fails with a message pointing out the problem.
	 */
	protected final RuntimeException __errorUnimplementedVisitCase(String methodName) {
		throw new AssertionError(
			"Visit method '" + methodName + "' not implemented in configuration type '"
				+ getConfigurationInterface().getName() + "'.");
	}

	private void sendEventSet(PropertyDescriptor property, Object oldValue, Object newValue) {
		ConfigurationChange event = null;
		Map<NamedConstant, ListenerList> listenersByProperty = _listenersByProperty;
		if (listenersByProperty == null || listenersByProperty.isEmpty()) {
			return;
		}
		event = notifyEventSet(property, oldValue, newValue, event, listenersByProperty.get(ALL));
		notifyEventSet(property, oldValue, newValue, event, getListener(listenersByProperty, property));
	}

	private void sendEventModify(PropertyDescriptor property, Kind kind, int index, Object element) {
		ConfigurationChange event = null;
		Map<NamedConstant, ListenerList> listenersByProperty = _listenersByProperty;
		if (listenersByProperty == null || listenersByProperty.isEmpty()) {
			return;
		}
		event = notifyEventModify(property, kind, index, element, event, listenersByProperty.get(ALL));
		notifyEventModify(property, kind, index, element, event, getListener(listenersByProperty, property));
	}

	private ListenerList getListener(Map<NamedConstant, ListenerList> listenersByProperty,
			PropertyDescriptor property) {
		return listenersByProperty.get(property.getListenerIdentifier());
	}

	private ConfigurationChange notifyEventSet(final PropertyDescriptor property, final Object oldValue,
			final Object newValue, ConfigurationChange event, ListenerList listeners) {
		if (listeners == null || listeners.isEmpty()) {
			return null;
		}

		return sendEventSet(property, oldValue, newValue, event, listeners);
	}

	private ConfigurationChange notifyEventModify(final PropertyDescriptor property, Kind kind, int index,
			Object element, ConfigurationChange event, ListenerList listeners) {
		if (listeners == null || listeners.isEmpty()) {
			return null;
		}

		return sendEventModify(property, kind, index, element, event, listeners);
	}

	private ConfigurationChange sendEventSet(final PropertyDescriptor property, final Object oldValue,
			final Object newValue, ConfigurationChange event, ListenerList listeners) {
		if (event == null) {
			event = ChangeEvent.newSetEvent(this, property, oldValue, newValue);
		}
		listeners.send(event);
		return event;
	}

	private ConfigurationChange sendEventModify(final PropertyDescriptor property, Kind kind, int index, Object element,
			ConfigurationChange event, ListenerList listeners) {
		if (event == null) {
			event = ChangeEvent.newModifyEvent(this, property, kind, index, element);
		}
		listeners.send(event);
		return event;
	}

	/**
	 * Method to check whether this {@link ConfigurationItem} is {@link #equals(Object) "equal by
	 * value"} to the given object.
	 * 
	 * @see EqualityByValue#equals(Object)
	 */
	protected boolean __equalsByValue(Object other) {
		if (!(other instanceof ConfigurationItem)) {
			return false;
		}

		return ConfigEquality.INSTANCE_ALL_BUT_DERIVED.equals(this, (ConfigurationItem) other);
	}

	/**
	 * Method to check get the {@link #hashCode() hashCode} for this {@link ConfigurationItem} based
	 * on the hash codes of the values.
	 * 
	 * @see EqualityByValue#hashCode()
	 */
	protected int __hashCodeByValue() {
		return ConfigEquality.INSTANCE_ALL_BUT_DERIVED.hashCode(this);
	}

	/**
	 * Report an unknown property (e.g. a property of another configuration type) found in a generic
	 * access method.
	 *
	 * @param property
	 *        The {@link PropertyDescriptor} that is resolved against the current implementation.
	 * @throws IllegalArgumentException
	 *         Unconditionally fails mentioning the property that was not found.
	 */
	protected final RuntimeException __unknown(PropertyDescriptor property) {
		throw new IllegalArgumentException("No such property '" + property
			+ "' in configuration type '" + getConfigurationInterface().getName() + "'.");
	}

	/**
	 * Hook reporting an internal error from generated property lookup methods for a property was
	 * found in the local index but not covered by the local switch case.
	 *
	 * @param index
	 *        The internal index that was found but not covered by the local switch case.
	 * @throws AssertionError
	 *         Unconditionally fails mentioning the property and its wrong index.
	 */
	protected final RuntimeException __missing(PropertyDescriptor property, int index) {
		throw new AssertionError(
			"Property '" + property + "' not registered with index " + index + " in configuration type '"
				+ getConfigurationInterface().getName() + "'.");
	}

	@Override
	public Unimplementable unimplementable() {
		return null;
	}

	/**
	 * Checks that the given value is not <code>null</code>.
	 * 
	 * <p>
	 * Hook called from generic setters of properties with primitive type.
	 * </p>
	 */
	protected static final void __checkPrimitive(PropertyDescriptor property, Object value) {
		if (value == null) {
			throw PropertyDescriptorImpl.errorPrimitiveIsNull(property);
		}
	}

	/**
	 * Utility called from indexed setters of indexed properties.
	 *
	 * @param list
	 *        The internal list implementation of the property.
	 * @param index
	 *        The index to set.
	 * @param nullValue
	 *        The null value to fill indices before the given index.
	 * @param value
	 *        The value to set at the given index.
	 */
	protected static final <T> void __setIndexed(List<T> list, int index, T nullValue, T value) {
		int size = list.size();
		if (index < size) {
			list.set(index, value);
		} else {
			while (index > size) {
				list.add(nullValue);
				size++;
			}
			// assert index <= size
			list.add(index, value);
		}
	}

	@Override
	public String toString() {
		return TypedConfiguration.toString(this);
	}

	private static final class ChangeEvent implements ConfigurationChange {

		public static ChangeEvent newSetEvent(ConfigurationItem sender, PropertyDescriptor property,
				Object oldValue, Object newValue) {
			return new ChangeEvent(sender, property, Kind.SET, oldValue, newValue, -1);
		}

		public static ChangeEvent newModifyEvent(ConfigurationItem sender, PropertyDescriptor property,
				Kind kind, int index, Object element) {
			return new ChangeEvent(sender, property, kind, element, element, index);
		}

		private ConfigurationItem _model;

		private final PropertyDescriptor _property;

		private final Object _oldValue;

		private final Object _newValue;

		private final Kind _kind;

		private final int _index;

		/**
		 * Creates a {@link ChangeEvent}.
		 */
		public ChangeEvent(ConfigurationItem model, PropertyDescriptor property, Kind kind, Object oldValue,
				Object newValue, int index) {
			_model = model;
			_property = property;
			_kind = kind;
			_oldValue = oldValue;
			_newValue = newValue;
			_index = index;
		}

		@Override
		public Kind getKind() {
			return _kind;
		}

		@Override
		public ConfigurationItem getModel() {
			return _model;
		}

		@Override
		public PropertyDescriptor getProperty() {
			return _property;
		}

		@Override
		public Object getOldValue() {
			return _oldValue;
		}

		@Override
		public Object getNewValue() {
			return _newValue;
		}

		@Override
		public int getIndex() {
			return _index;
		}
	}

	static final class ListenerList extends ArrayList<ConfigurationListener> {

		private boolean _iterating;

		public ListenerList() {
			super();
		}

		public ListenerList(ListenerList other) {
			super(other);
		}

		@Override
		public boolean add(ConfigurationListener e) {
			if (contains(e)) {
				return false;
			}
			return super.add(e);
		}

		public void send(ConfigurationChange event) {
			boolean before = _iterating;
			_iterating = true;
			try {
				for (ConfigurationListener listener : this) {
					listener.onChange(event);
				}
			} finally {
				_iterating = before;
			}
		}

		public ListenerList copy() {
			return new ListenerList(this);
		}

		public boolean isIterating() {
			return _iterating;
		}

	}

}
