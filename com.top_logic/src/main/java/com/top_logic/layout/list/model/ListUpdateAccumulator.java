/*
 * SPDX-FileCopyrightText: 2007 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.layout.list.model;

import java.util.ArrayList;

import javax.swing.ListModel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import com.top_logic.basic.UnreachableAssertion;
import com.top_logic.layout.basic.AbstractAttachable;

/**
 * {@link ListDataListener} and {@link ListSelectionListener} implementation
 * consolidates multiple (possibly overlapping) events into a sequence of
 * non-overlapping events.
 * 
 * <p>
 * A {@link ListDataEvent} or {@link ListSelectionEvent} reposts a range of a
 * {@link ListModel} that has been added, removed, or changed. In a web
 * application, the client-side view of a {@link ListModel} cannot be updated
 * immediately after its server-side model receives an event, but the updates
 * can only be generated when the response is sent to the client. In the
 * response, each list element must be touched only exactly once. This is
 * accomplished by routing the view's model events to an instance of
 * {@link ListUpdateAccumulator} and sending only updates to the client-side
 * view that result from events generated by a call to
 * {@link #forwardConsolidatedEvents(ListDataListener)}, which produces a
 * consolidated event sequence of non-overlapping events.
 * </p>
 * 
 * @author <a href="mailto:bhu@top-logic.com">Bernhard Haumacher</a>
 */
public class ListUpdateAccumulator extends AbstractAttachable implements ListDataListener, ListSelectionListener {

	private static final Integer CHANGED = Integer.valueOf((-1));
	private static final Integer ADDED   = Integer.valueOf((-2));

	private int initialBaseSize = -1;
	private ListModel base;
	private ListSelectionModel selection;
	
	/**
	 * List with a status entry for each entry currently present in the
	 * {@link #base} model.
	 * 
	 * <p>
	 * The status is either a (non-negative) index into the {@link #base} model
	 * at the time {@link #attach()} was called, or one of {@link #CHANGED} or
	 * {@link #ADDED} for an entry that was changed or added after
	 * {@link #attach()} was called.
	 * </p>
	 */
	private ArrayList elementState;

	public ListUpdateAccumulator(ListModel base, ListSelectionModel selection) {
		this.base = base;
		this.selection = selection;
	}
	
	@Override
	public void contentsChanged(ListDataEvent e) {
		initializeState();
		processChanged(e.getIndex0(), e.getIndex1() + 1);
	}

	@Override
	public void intervalAdded(ListDataEvent e) {
		initializeState();
		for (int stop = e.getIndex1() + 1, n = e.getIndex0(); n < stop; n++) {
			elementState.add(n, ADDED);
		}
	}

	@Override
	public void intervalRemoved(ListDataEvent e) {
		initializeState();
		for (int stop = e.getIndex0(), n = e.getIndex1(); n >= stop; n--) {
			elementState.remove(n);
		}
	}
	
	@Override
	public void valueChanged(ListSelectionEvent e) {
		initializeState();
		int startIndex = e.getFirstIndex();
		int stopIndex = e.getLastIndex() + 1;
		
		// Drop change events that are out of bounds. Those events can occurr,
		// if listening to a list model and a selection model and selected
		// elements at the end of the list are removed (and deselected).
		// Removing and deselecting fires events, and the deselection events are
		// out of bounds, because the size of the underlying list model was
		// decreased.
		stopIndex = Math.min(elementState.size(), stopIndex);
		startIndex = Math.max(0, startIndex);
		
		processChanged(startIndex, stopIndex);
	}
	
	private void processChanged(int startIndex, int stopIndex) {
		for (int n = startIndex; n < stopIndex; n++) {
			if (elementState.get(n) == ADDED) {
				// Adding has priority over changing, because in the
				// consolidated view, it does not matter, whether an added
				// element has been changed later on.
				continue;
			}
			elementState.set(n, CHANGED);
		}
	}
	
	public boolean hasUpdates() {
		return this.elementState != null;
	}
	
	public void reset() {
		if (isAttached()) {
			initialBaseSize = base.getSize();
			elementState = null;
		}
	}
	
	public void forwardConsolidatedEvents(ListDataListener target) {
		if (! hasUpdates()) return;
		
		int cnt = elementState.size();
		int expectedIndex = 0;
		int currentIndex = 0;
		while (currentIndex < cnt) {
			int state = getState(currentIndex);
			if (state == expectedIndex) {
				// No change.
				expectedIndex++;
				currentIndex++;
			}
			else if (state >= 0) {
				int nextOriginalIndex = state;
				// An element of the original base model is located at the
				// current index. Because the expected index does not match,
				// some elements must have been removed. With respect to the
				// initial list state, the removed elements start with the
				// expected index and end with one less than the current state.
				// With respect to the list state, an observer that has
				// processed all events sent by this method so far, the removal
				// range starts with the current index and has removed (original
				// index - expected index) elements.
				assert expectedIndex < nextOriginalIndex;
				
				int removedCount = nextOriginalIndex - expectedIndex;
				
				target.intervalRemoved(
					new ListDataEvent(base, ListDataEvent.INTERVAL_REMOVED, currentIndex, currentIndex + removedCount - 1));
				
				// Now, the expected index matches the state. Both can be
				// immediately incremented by one (this is actually a code
				// duplication of the first branch).
				expectedIndex = nextOriginalIndex + 1;
				currentIndex++;
			}
			else if (state == ADDED.intValue()) {
				int addStopIndex = currentIndex + 1;
				while (addStopIndex < cnt && getState(addStopIndex) == ADDED.intValue()) addStopIndex++;
				target.intervalAdded(
					new ListDataEvent(base, ListDataEvent.INTERVAL_ADDED, currentIndex, addStopIndex - 1));
				currentIndex = addStopIndex;
			}
			else if (state == CHANGED.intValue()) {
				int changeStopIndex = currentIndex + 1;
				while (changeStopIndex < cnt && getState(changeStopIndex) == CHANGED.intValue()) changeStopIndex++;
				target.contentsChanged(
					new ListDataEvent(base, ListDataEvent.CONTENTS_CHANGED, currentIndex, changeStopIndex - 1));
				int changeCount = changeStopIndex - currentIndex;
				currentIndex = changeStopIndex;
				
				// A change has replaced original elements.
				expectedIndex += changeCount;
			} else {
				throw new UnreachableAssertion("Unknown state:" + state);
			}
		}
		
		if (expectedIndex < initialBaseSize) {
			// Elements at the list's tail have been removed.
			int removedCount = initialBaseSize - expectedIndex;
			
			target.intervalRemoved(
				new ListDataEvent(base, ListDataEvent.INTERVAL_REMOVED, currentIndex, currentIndex + removedCount - 1));
		}
	}

	private int getState(int n) {
		int state = ((Integer) elementState.get(n)).intValue();
		return state;
	}

	@Override
	protected void internalAttach() {
		initialBaseSize = base.getSize();
		base.addListDataListener(this);
		if (selection != null) 
			selection.addListSelectionListener(this);
	}
	
	@Override
	protected void internalDetach() {
		initialBaseSize = -1;
		elementState = null;
		base.removeListDataListener(this);
		if (selection != null) 
			selection.removeListSelectionListener(this);
	}

	private void initializeState() {
		if (elementState == null) {
			elementState = new ArrayList(initialBaseSize);
			for (int n = 0; n < initialBaseSize; n++) {
				elementState.add(Integer.valueOf(n));
			}
		}
	}

	public void setListModel(ListModel newBase) {
		if (isAttached()) 
			throw new IllegalStateException("Cannot change base models while being attached.");

		this.base = newBase;
	}

	public void setSelectionModel(ListSelectionModel newSelection) {
		if (isAttached()) 
			throw new IllegalStateException("Cannot change base models while being attached.");

		this.selection = newSelection;
	}

}
