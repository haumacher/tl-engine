<p>Das TopLogic-Modell und seine Daten werden automatisch versioniert. D.h. Informationen werden bei Änderung - seien es Änderungen am Modell oder Änderungen an Anwendungsdaten - nicht überschrieben. Stattdessen erzeugt jede Änderung eine neue Version. Alte Versionen bleiben erhalten und können zum Vergleich oder zu Zwecken der Revisionssicherheit herangezogen werden.</p>
<h2>Technische Versionierung (Revisions)</h2>
<p>Technisch erzeugt jedes Commit in der TopLogic-Datenbank eine neue Version (Revision). Die Version wird über eine fortlaufende Revisionsnummer identifiziert. Über diese Revisionsnummer kann jeder Stand des Systems seit seiner Installation rekonstruiert werden. Dabei ist aber nur der aktuelle Datenstand (mit der speziellen Revision "Current") veränderlich. Alle abgeschlossenen Versionen sind unveränderlich. Dafür werden zwei unterschiedliche Zustände von Objekte unterschieden. Es gibt aktuelle Objekte (aus dem aktuellen Datenstand) und historische Objekte aus einer abgeschlossenen Version. Eine Transaktion im System Ändert den Zustand von einem oder mehreren aktuellen Objekten und schreibt diese Änderung in einer neuen Version fest.</p>
<p>Normale Sichten und Suchanfragen operieren immer im aktuellen Datenstand. Um eine abgeschlossene Version anzuzeigen, muss entweder zu einem aktuellen Objekt eine historische Version in einer bestimmte Revision herausgesucht werden (vgl. <a class="tlObject" data-custom="false" href="?page=inRevision&amp;uuid=db80561c-09ab-4286-bf9e-1ccd8387fa99">Objekt in einer Revision</a>) oder es muss über eine sog. historische Referenz "in die Vergangenheit" navigiert werden.</p>
<h2>Historische Referenzen</h2>
<p>Über <a class="tlObject" data-custom="false" href="?page=References&amp;uuid=24f0521d-7151-428c-9619-cc92816b60be">Referenzen</a> werden Beziehungen zwischen Objekten abgebildet. Eine normale Referenz hat die Historisierung "Aktuell". D.h. die Referenz an einem aktuellen Objekt hat als Ziel wiederum ein oder mehrere aktuelle Objekte. Navigiert man ausgehend von einem historischen Objekt (aus einer stabilen Version) über eine Referenz mit Historisierung "Aktuell", erhält man als Ergebnis ebenfall historische Objekte aus derselben Version wie das Ausgangsobjekt. Man kann sagen, die Navigation über eine aktuelle Referenz behält die Zeitschiene bei.</p>
<p>Um sich Referenzen auf eine stabile Version speichern zu können, benötigt man eine Referenz mit Historisierung "Historisch". In eine solche Refernz können historische Versionen von Objekten gespeichert werden. Ausgehend von einem aktuellen Objekt erhält man bei Navigation über eine historische Referenz also immer ein historisches Objekt aus einer stabilen Version. Dasselbe gilt natürlich auch wenn man eine historische Referenz eines historischen Objektes navigiert. Das Ergebnis ist dann ebenfalls ein historisches Objekt aber möglicherweise aus eine anderen Zeitschiene als das Ausgangsobjekt. Navigation über historische Referenzen kann also die Zeitschiene wechseln.</p>
<p>Referenzen mit Historisierung "Historisch" haben noch eine Besonderheit. Speichert man in eine historsiche Referen eines aktuellen Objektes ein oder mehrere andere aktuelle Objekte, so wird die Version dieser Zielobjekte im Commit der Transaktion festgeschrieben. Navigiert man dieselbe historische Referenz nach dem Commit, so erhält man ausgehend von einem aktuellen Objekt historische Versionen der Zielobjekte in der durch das Commit erstellten Version. Ändert man in einer weiteren Transaktion ihre aktuellen Variante, hat das keine Auswirkung auf die Zielobjekte der historischen Referenz. Man kann sagen, dass das Speichern von akutellen Objekten in historische Referenzen deren Zustand beim Commit einfriert. Aus einer aktuellen Referenz (einer Referenz auf ein aktuelles Objekt) wird im Commit eine stabile Referenz (eine Referenz auf ein unveränderliches historisches Objekt).</p>
<p>Als letzte Option für die Historisierung bleibt die Geschmacksrichtung "Gemischt". In eine Referenz mit Historisierung "Gemischt" können sowohl historische als auch aktuelle Objekte gespeichert werden. Die Werte bleiben hier exakt so erhalten, wie sie gespeichert wurden. es findet also keine Stabilisierung aktuelle Referenzen statt. Wird ein aktuelles Objekt in eine gemischte Referenz gespeichert, erhält man nach dem Commit immer noch eine aktuelle Referenz. Gleiches gilt für eine historische Referenz.</p>
<h2>Fachliche Versionierung</h2>
<p>Jede Änderung am System erzeugt zwar technisch gesehen eine eigene Version, diese hat aber i.d.R. fachlich keine Bedeutung. Normalerweise möchte man ganz spezielle Versionen in einem System festhalten und diesen eine fachliche Bezeichnung (wie einen Berichtsabschluss, ein Release, o.ä) geben. Die technische Versionierung kann aber auch dafür verwendet, werden, den Zustand eines oder mehrerer Objekte zu einem gewissen Zeitpunkt zu rekonstruieren (vgl. <a class="tlObject" data-custom="false" href="?page=revisionAt&amp;uuid=b64912ed-b629-44bd-b80e-7814c88b64fc">Revision zu einem Zeitpunkt</a>).</p>
<p>Ein fachliches Festscheiben eines Systemzustandes erreicht man in der Regel über das Speichern eines aktuellen Objektes in eine historische Referenz. Hierbei wird der Zustand dieses Objektes (und damit aller mit diesem Objekt über aktuelle Referenzen verbundener Objekte) festgeschrieben. Da die Referenz im Commit zu einer historischen Referenz auf das Objekt zum Zeitpunkt des Commits stabilisert wird, repräsentiert diese Referenz nach dem Commit eine fachliche Version.</p>
<h2>Versionierung abschalten</h2>
<p>Wenn in einem System keine Versionierung notwendig ist, kann diese entweder global (für alle Typen) oder spezifisch für einzelne Tabellen abgeschaltet werden. Siehe hierzu <a href="https://dev.top-logic.com/doc/TL-7-latest/javadoc/#com.top_logic.knowledge.service.KnowledgeBaseConfiguration#getDisableVersioning()">Versionierung global abschalten</a> oder <a href="https://dev.top-logic.com/doc/TL-7-latest/javadoc/#com.top_logic.dob.schema.config.MetaObjectConfig#isVersioned()">Versionierung für Tabelle deaktivieren</a>. Bei parzieller Versionierung muss aber beachtet werden, dass ein versionierter Typ keine Referenzen auf unversionierte Typen halten kann. Andernfalls könnte sich der Zustand eines stabilen Version nachträglich verändern, wenn in der Folge unversionierte Objekte gelöscht werden. Für Referenzen von unversionierten Objekten gibt es aber keine Einschänkungen. Sie können entweder andere unversionierte oder versionierte Objekte enthalten.</p>
<p>Siehe hierzu auch <a class="tlObject" data-custom="false" href="?page=Versioning&amp;uuid=9320ab94-eb74-4ee2-ba9f-3a223e25570d">Datenversionierung</a>.</p>