<h2 id="Hintergrund">Hintergrund</h2>
<p>Das <code class="hljs inlineCode">ScriptingFramework</code> muss Referenzen auf die in Actions verwendeten Objekte erstellen, um diese beim Abspielen der Skripte wiederfinden zu können. Für die meisten <code class="hljs inlineCode">TLObjects</code> sowie einige primitive Typen kann das <code class="hljs inlineCode">ScriptingFramework</code> derartige Referenzen von sich aus erstellen. An einigen Stellen der Anwendungen muss es aber Referenzen auf Objekte erstellen, die es nicht direkt unterstützt. Für solche Fälle gibt die Klassen <code class="hljs inlineCode">ModelNamingScheme</code> sowie <code class="hljs inlineCode">ValueNamingScheme</code>.</p>
<h2 id="ModelNamingSchemes"><code class="hljs inlineCode">ModelNamingSchemes</code></h2>
<p><code class="hljs inlineCode">ModelNamingSchemes</code> identifizieren Objekte, indem sie ein <code class="hljs inlineCode">ModelName</code> bauen, der das Fachobjekt eindeutig identifiziert. <code class="hljs inlineCode">ModelNames</code> sind Datencontainer (genauer <code class="hljs inlineCode">ConfigItems</code>), die alle notwendigen Informationen speichern müssen, um das von ihnen identifizierte Objekt später wiederfinden zu können. Das <code class="hljs inlineCode">ModelNamingScheme</code> ist dabei dafür zuständig, die notwendigen Informationen zu sammeln und im <code class="hljs inlineCode">ModelName</code> zu speichern, sowie später anhand dieser Informationen das Objekt wiederzufinden.</p>
<p>Typischerweise werden <code class="hljs inlineCode">ModelNamingSchemes</code> für <code class="hljs inlineCode">TLObjects</code> gebaut, die eine Spezialbehandlung beim Wiederfinden benötigen. Das Framework verwendet folgende Strategien, um einen <code class="hljs inlineCode">TLObjects</code> aufzuzeichnen und beim Abspielen wiederzufinden:</p>
<ul>
 <li>Für <code class="hljs inlineCode">TLObjects</code> können die Attribute, die ihn eindeutig identifizieren, im <code class="hljs inlineCode">IndexedObjectNaming</code> konfiguriert werden: 
  <pre><code>&lt;config config:interface="com.top_logic.layout.scripting.recorder.ref.value.object.IndexedObjectNaming$GlobalConfig"&gt;
    &lt;types&gt;
        &lt;type name="tl.legacy.tabletypes:FastListTable" attributes="name"/&gt;
        &lt;type name="tl.legacy.tabletypes:FastListEltTable" attributes="owner,name"/&gt;
        &lt;type name="Contacts:Contact.Person" attributes="name,firstname"/&gt;
    &lt;/types&gt;
&lt;/config&gt;
</code></pre></li>
 <li><code class="hljs inlineCode">StructuredElement</code> werden anhand ihres Namens und des Pfads zur Wurzel identifiziert.</li>
</ul>
<p>Für den Fall, dass beide Optionen nicht anwendbar sind, gibt es die <code class="hljs inlineCode">ModelNamingSchemes</code>. Die Methode <code class="hljs inlineCode">ModelNamingSchemes.initName(N name, M model)</code> bekommt einen leeren Namen (ein <code class="hljs inlineCode">ModelName</code>, also ein <code class="hljs inlineCode">ConfigItem</code>) übergeben und muss diesen mit den Werten aus dem Fachobjekt ("model") füllen. Die Methode <code class="hljs inlineCode">locateModel(ActionContext context, N name)</code> bekommt diesen Namen dann beim Abspielen übergeben, und muss das Objekt wiederfinden und zurückliefern. Dazu stehen ihr zum einen natürlich die Anwendung (also insbesondere alle gestarteten Module) und zum anderen die Informationen und Methoden im <code class="hljs inlineCode">ActionContext</code> zur Verfügung.</p>
<p><code class="hljs inlineCode">ModelNamingSchemes</code> müssen in der Konfiguration des <code class="hljs inlineCode">ModelResolvers</code> eingetragen werden. Bsp:</p>
<pre><code>&lt;application xmlns:config="http://www.top-logic.com/ns/config/6.0"&gt;
    &lt;services&gt;
        &lt;config service-class="com.top_logic.layout.scripting.recorder.ref.ModelResolver"&gt;
            &lt;instance&gt;
                &lt;schemes&gt;
                    &lt;scheme class="com.top_logic.layout.scripting.recorder.ref.value.ClassNaming" priority="preferred"/&gt;
                    &lt;scheme class="com.top_logic.layout.scripting.recorder.ref.value.object.IndexedObjectNaming" priority="fallback"/&gt;
                    &lt;scheme class="com.top_logic.layout.scripting.recorder.specialcases.PersonalizedExpandableNamingScheme"/&gt;
                &lt;/schemes&gt;
            &lt;/instance&gt;
        &lt;/config&gt;
    &lt;/services&gt;
&lt;/application&gt;
</code></pre>
<h3 id="Priorität">Priorität</h3>
<p><code class="hljs inlineCode">ModelNamingSchemes</code> haben zum einen eine explizite Priorität. Diese wird bei der Deklaration angegeben:</p>
<pre><code>&lt;scheme class="com.top_logic.element.layout.scripting.TLObjectByLabelNaming"
    priority="preferred"/&gt;
</code></pre>
<p>Diese Prioritäten sind in der <code class="hljs inlineCode">top-logic.config.xml</code> im Abschnitt des <code class="hljs inlineCode">ModelResolvers</code> definiert:</p>
<pre><code>&lt;priorities&gt;
    &lt;!-- The last priority in the list is the most important one. --&gt;
    &lt;priority value="resolve-only" /&gt;
    &lt;priority value="fallback" /&gt;
    &lt;priority value="default" /&gt;
    &lt;priority value="preferred" /&gt;
&lt;/priorities&gt;
</code></pre>
<p>Wird keine Priorität angegeben, entspricht das der Priorität <code class="hljs inlineCode">default</code>.</p>
<p>Zum anderen haben die <code class="hljs inlineCode">ModelNamingSchemes</code> eine implizite Priorität: Das zuletzt deklarierte <code class="hljs inlineCode">ModelNamingScheme</code> wird verwendet. Dabei ist die explizite Priorität immer wichtiger als die implizite. Anwendungen können die Priorität von <code class="hljs inlineCode">ModelNamingSchemes</code> anpassen. Dazu muss in die Konfiguration des <code class="hljs inlineCode">ModelResolvers</code> zum Beispiel folgendes eingetragen werden:</p>
<pre><code>&lt;scheme class="com.top_logic.element.layout.scripting.TLObjectByLabelNaming"
    priority="preferred"/&gt;
</code></pre>
<p>Beispiel:</p>
<pre><code>&lt;application xmlns:config="http://www.top-logic.com/ns/config/6.0"&gt;
    &lt;services&gt;
        &lt;config service-class="com.top_logic.layout.scripting.recorder.ref.ModelResolver"&gt;
            &lt;instance&gt;
                &lt;schemes&gt;
                    &lt;scheme class="com.top_logic.element.layout.scripting.TLObjectByLabelNaming"
                        priority="preferred"/&gt;
                &lt;/schemes&gt;
            &lt;/instance&gt;
        &lt;/config&gt;
    &lt;/services&gt;
&lt;/application&gt;
</code></pre>
<h2 id="ValueNamingSchemes"><code class="hljs inlineCode">ValueNamingSchemes</code></h2>
<p><code class="hljs inlineCode">ValueNamingSchemes</code> funktionieren ähnlich, mit zwei Unterschieden: Erstens verwenden sie keine <code class="hljs inlineCode">ModelNames</code>, sondern speichern ihre Informationen in Maps. Und zweitens müssen sie die gesuchten Objekte nicht selber auffinden, sondern sie nur aus einer gegebenen Liste von Objekten wiedererkennen können. Typischerweise werden zB. für nicht-<code class="hljs inlineCode">TLObject</code>-Zeilenobjekte von Tabellen und andere transiente Objekte wie <code class="hljs inlineCode">ProjectStructureEditComponent.NewObject</code> verwendet.</p>
<p>Als Grundmenge der Objekte, aus der das <code class="hljs inlineCode">ValueNamingScheme</code> das Objekt wiedererkennen muss, wird zB. in Tabellen die Menge der Zeilenobjekte verwendet. Beim Abspielen der Action wird dann für jedes dieser Objekte nacheinander <code class="hljs inlineCode">ValueNamingScheme.matches(Map&lt;String, Object&gt; name, M model)</code> aufgerufen. Diese Methode bekommt als ersten Parameter den aufgezeichneten "Namen" (die Map der relevanten Werte) sowie als zweiten Parameter eines der möglichen Objekte. Sie muss dann zurückliefern, ob der Name zu diesem Objekt passt. Dafür genügt es, diese Methode mittels <code class="hljs inlineCode">return matchesDefault(name, model);</code> zu implementieren. Dann wird für das Model der Name gebaut und dieser mit dem übergebenen Namen verglichen. Für Performance-Optimierungen oder Spezialfälle kann die Methode aber auch anders implementiert werden.</p>
<p><code class="hljs inlineCode">ValueNamingSchemes</code> müssen in der Legacy-Konfiguration in der Section <code class="hljs inlineCode">ValueNamingSchemeRegistry</code> eingetragen werden. Bsp:</p>
<pre><code>&lt;section name="ValueNamingSchemeRegistry"&gt;
  &lt;entry name="com.top_logic.common.folder.model.FolderNode" value="com.top_logic.common.folder.model.FolderNode$Naming"/&gt;
  &lt;entry name="com.top_logic.knowledge.wrap.Document" value="com.top_logic.knowledge.wrap.WrapperNaming"/&gt;
  &lt;entry name="com.top_logic.knowledge.wrap.WebFolder" value="com.top_logic.knowledge.wrap.WrapperNaming"/&gt;
&lt;/section&gt;
</code></pre>
<p>In den vollqualifierten Namen der Klassen müssen die Punkte vor inneren Klassen wie üblich durch '$' ersetzt werden.</p>
<h2 id="I18N">I18N</h2>
<p>Für <code class="hljs inlineCode">ModelNamingSchemes</code> und <code class="hljs inlineCode">ValueNamingSchemes</code> müssen in den I18N Übersetzungen eingetragen werden, damit diese in der <a href="?page=ScriptingGui&amp;uuid=60242912-b6b8-420a-bbef-ed37857dcfb5" data-custom="false" class="tlObject">Scripting Gui</a> als Text (statt als XML) darstellt werden können. Dabei wird <s><a href="http://tl/trac/ticket/11505" title="#11505: enhancement: Template language for internationalizing typed configuration items (closed: fixed)" target="_blank">#11505</a></s> verwendet, um Ausdrücke in den I18N schreiben zu können.</p>