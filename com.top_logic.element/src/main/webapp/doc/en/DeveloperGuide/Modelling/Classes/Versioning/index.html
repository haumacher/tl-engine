<p>The TopLogic model and its data are automatically versioned. This means that information is not overwritten when changes are made - whether to the model or to application data. Instead, each change creates a new version. Old versions are preserved and can be used for comparison or revision control purposes.</p>
<h2>Technical versioning (revisions)</h2>
<p>Technically, each commit creates a new version (revision) in the TopLogic database. The version is identified by a consecutive revision number. This revision number can be used to reconstruct any status of the system since it was installed. However, only the current data status (with the special revision "Current") can be changed. All completed versions are unchangeable. For this two different states of objects are distinguished. There are current objects (from the current data state) and historical objects from a completed version. A transaction in the system changes the state of one or more current objects and writes this change in a new version.</p>
<p>Normal views and search queries always operate in the current state of data. To display a completed version, either a historical version in a specific revision must be found for a current object (cf. <a class="tlObject" data-custom="true" href="?page=inRevision&amp;uuid=db80561c-09ab-4286-bf9e-1ccd8387fa99">Object in a revision</a>) or a so-called historical reference must be used to navigate "into the past".</p>
<h2>Historical references</h2>
<p><a class="tlObject" data-custom="true" href="?page=References&amp;uuid=24f0521d-7151-428c-9619-cc92816b60be">References</a> are used to represent relationships between objects. A normal reference has the historization "Current". This means that the reference to a current object has one or more current objects as its target. If you navigate from a historical object (from a stable version) via a reference with the historization "Current", you will also receive historical objects from the same version as the source object as a result. It can be said that navigation via a current reference preserves the time line.</p>
<p>To be able to save references to a stable version, you need a reference with historization "Historical". Historical versions of objects can be stored in such a reference. Starting from a current object, one always receives a historical object from a stable version when navigating via a historical reference. The same applies, of course, if you navigate a historical reference of a historical object. The result is then also a historical object but possibly from a different time line than the original object. Navigation over historical references can therefore change the timeline.</p>
<p>References with historicization "Historic" have another special feature. If one stores one or more other current objects in a historical reference of a current object, then the version of these target objects is fixed in the commit of the transaction. If one navigates the same historical reference after the commit, then one receives, starting from a current object, historical versions of the target objects in the version created by the commit. If one changes their current variant in another transaction, this has no effect on the target objects of the historical reference. It can be said that saving current objects in historical references freezes their access at commit. A current reference (a reference to a current object) becomes a stable reference (a reference to an immutable historical object) in the commit.</p>
<p>The last option left for historization is the flavor "Mixed". Both historical and current objects can be stored in a reference with historization "Mixed". The values are preserved here exactly as they were saved. so there is no stabilization current references. If a current object is stored in a mixed reference, you still get a current reference after the commit. The same applies to a historical reference.</p>
<h2>Technical versioning</h2>
<p>Each change at the system produces technically seen its own version, this has however as a rule technically no meaning. Normally one would like to hold very special versions in a system and give these a technical designation (like a report conclusion, a release, or the like). However, technical versioning can also be used to reconstruct the state of one or more objects at a certain point in time (cf. <a class="tlObject" data-custom="true" href="?page=revisionAt&amp;uuid=b64912ed-b629-44bd-b80e-7814c88b64fc">revision at a point in time</a>).</p>
<p>A technical fixing of a system condition one reaches as a rule over the storage of a current object into a historical reference. Here the condition of this object (and thus all objects connected with this object over current references) is fixed. Since the reference in the commit is stabilized to a historical reference to the object at the time of the commit, this reference represents a functional version after the commit.</p>
<h2>Switch off versioning</h2>
<p>If versioning is not necessary in a system, it can be switched off either globally (for all types) or specifically for individual tables. See <a href="https://dev.top-logic.com/doc/TL-7-latest/javadoc/#com.top_logic.knowledge.service.KnowledgeBaseConfiguration#getDisableVersioning()">Disable versioning globally</a> or <a href="https://dev.top-logic.com/doc/TL-7-latest/javadoc/#com.top_logic.dob.schema.config.MetaObjectConfig#isVersioned()">Disable versioning for table</a>. With parcial versioning, however, it must be noted that a versioned type cannot hold references to unversioned types. Otherwise the state of a stable version could change afterwards if unversioned objects are subsequently deleted. However, there are no restrictions for references of unversioned objects. They can contain either other unversioned or versioned objects.</p>