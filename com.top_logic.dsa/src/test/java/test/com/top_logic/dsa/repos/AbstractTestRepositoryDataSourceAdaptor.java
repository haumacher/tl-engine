/*
 * SPDX-FileCopyrightText: 2002 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package test.com.top_logic.dsa.repos;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

import junit.framework.TestCase;

import com.top_logic.basic.config.PolymorphicConfiguration;
import com.top_logic.basic.config.PropertyDescriptor;
import com.top_logic.basic.config.SimpleInstantiationContext;
import com.top_logic.basic.config.TypedConfiguration;
import com.top_logic.basic.io.FileUtilities;
import com.top_logic.dob.DataObject;
import com.top_logic.dob.ex.NoSuchAttributeException;
import com.top_logic.dsa.DAPropertyNames;
import com.top_logic.dsa.DatabaseAccessException;
import com.top_logic.dsa.evt.DataChangeEvent;
import com.top_logic.dsa.evt.DataChangeListener;
import com.top_logic.dsa.ex.DataChangeException;
import com.top_logic.dsa.repos.Repository;
import com.top_logic.dsa.repos.RepositoryDataSourceAdaptor;
import com.top_logic.dsa.repos.RepositoryDataSourceAdaptor.Config;

/**
 * Test case for the {@link com.top_logic.dsa.repos.RepositoryDataSourceAdaptor}.
 * 
 * @author    <a href="mailto:mga@top-logic.com">Michael Gänsler</a>
 */
public abstract class AbstractTestRepositoryDataSourceAdaptor extends TestCase implements DataChangeListener {

	/**
	 * Advanced configuration for a {@link RepositoryDataSourceAdaptor} to allow setting some parameters for test issues. 
	 * 
	 * @author    <a href="mailto:mga@top-logic.com">Michael Gänsler</a>
	 */
	public interface RepositoryConfig extends RepositoryDataSourceAdaptor.Config {

		/**
		 * @param string URL to be used.
		 */
		void setWorkareaURL(String string);
	}

	/** Demo Data used for Streaming */
    public static final byte DATA[] = 
		("This is some Data generated by " + AbstractTestRepositoryDataSourceAdaptor.class.getName()).getBytes();

    /** Array of names know to have problems */
    public static final String NAMES[] =  {
            "Test Name",
            "TestName",
		//            "_name_with_underscores_",
		//            "_^!$%&)(][}{=` +~'#,.-_",
            "~$name with Tilde and Dollar~",
            "~name with Tilde~" ,
            /*
             // This will not work in Solaris Â°, Â§, Â´ are no ascii characters
            "_Â°^!Â§$%&)(][}{=` Â´+~'#,.-_",
             // This will not work in NT or Unix due to / \ resp. ;
            " Â°^!\"Â§$%&/)(][}{=?\\`Â´*+~'#,.;:-_|><"
            "Space at End " // NT - just ignore the space at the end
            */
        };

	/** Array of names as List */
	public static final List<String> NAMESL = Arrays.asList(NAMES);

	private static final boolean NOFORCE = false;

    /** Last event we got via the DataChangeListener interface */
	protected Stack<DataChangeEvent> events = new Stack<>();
    
    /** Result returned by checkChangeAllow for Testing */
    protected boolean           allow = true;

    /**
     * Default constructor.
     *
     * @param name of test to execute.
     */
    public AbstractTestRepositoryDataSourceAdaptor (String name) {
        super (name);
    }

	/**
	 * Configuration for the {@link Repository} implementation to be tested.
	 */
	protected abstract PolymorphicConfiguration<?> getImplementationConfiguration();

	/**
	 * Cleanup the temporary area before actual Test starts.
	 */
	public abstract void doCleanup();

    /** Just Record the Event for later checking.
     */
    @Override
	public void dataChanged (DataChangeEvent anEvent)  {
        if (events != null)
            events.push(anEvent);
    }

    /**
	 * This method will be called before the change of data will be done.
	 *
	 * If, and only if, no listener is throwing an exception, the change will be allowed and
	 * executed. This method is needed, if the changes in the system will affect security reasons.
	 *
	 * @param anEvent
	 *        The event holding the information about the change.
	 * @throws DataChangeException
	 *         Thrown, when the change is not allowed, the contained message should explain the
	 *         reason.
	 */
    @Override
	public void checkChangeAllow(DataChangeEvent anEvent) throws DataChangeException {
		if (!allow) {
			throw new DataChangeException("Not allowed (Testing)");
		}
    }

    /** Return the Last Event and Clear it meanwhile */ 
    protected DataChangeEvent getLastEvent() {
		return events.pop();
    }
    
    /** Create an InputStream with some demo-Data */
    protected InputStream getInputStream() {
        return new ByteArrayInputStream(DATA);
    }

    /**
     * test Main functions of the dsa...
     */
    public void testMain () throws Exception {
        RepositoryDataSourceAdaptor rdsa = this.getNewRepositoryDSA ();
        
        assertTrue(rdsa.isRepository());
        int l = NAMES.length;
        
        // Create directories
        for (int i=0; i < l; i++) {
            String dirName  = NAMES[i];
            String xDirName = rdsa.createContainer("", dirName);
            assertTrue(!xDirName.endsWith("/"));
            
            // Method deleted
            //assertTrue(rdsa.getFile(xDirName).isDirectory());
           
            assertEquals(xDirName, rdsa.getName(dirName));
			this.checkProperties(rdsa, xDirName, true);
            for (int j=0; j < l; j++) 
            {
                String fileName  = NAMES[j];
                String xFileName = rdsa.createEntry(dirName, fileName, getInputStream());
				
                assertEquals(xDirName,  rdsa.getParent(xFileName));
                
                // Method deleted
                //assertTrue(rdsa.getFile(xFileName).exists());

                assertTrue(rdsa.isEntry     (xFileName));
                assertTrue(!rdsa.isContainer(xFileName));

                assertEquals(fileName,  rdsa.getName (xFileName));

                assertTrue(rdsa.unlock(xFileName));

				assertTrue(!fileName.equals(rdsa.createNewEntryName(xDirName, fileName, null)));
                assertTrue(rdsa.isEntry     (xFileName));
                assertTrue(!rdsa.isContainer(xFileName));
                assertEquals(fileName,  rdsa.getName (xFileName));
                assertEquals(xDirName,  rdsa.getParent(xFileName));

                assertTrue(rdsa.unlock  (xFileName));
                assertTrue(rdsa.lock    (xFileName));
                assertTrue(rdsa.unlock  (xFileName));
                
                assertTrue(rdsa.exists(xFileName));

                rdsa.getProperties(xFileName);
                
                // What is the expected format for this value ???
                rdsa.getURL(xFileName);
				this.checkProperties(rdsa, xFileName, false);
            }
            assertTrue(rdsa.exists      (dirName));
            assertTrue(rdsa.isContainer (dirName));
            assertTrue(!rdsa.isEntry    (dirName));
            
            rdsa.getURL(dirName);
    
            String entries[] = rdsa.getEntryNames(dirName);
            
            assertEquals(l , entries.length);
            for (int j=0; j < l; j++) {
                String entryName = rdsa.getName (entries[j]);
                assertTrue(entryName + " not found ", NAMESL.contains(entryName));
            }
        }
        
        // Delete all the directories again
        for (int i=0; i < l; i++) {
            String dirName  = NAMES[i];
            String entries[] = rdsa.getEntryNames(dirName);
            assertEquals(l , entries.length);
            try
            {
	            rdsa.delete(dirName, NOFORCE);   // will work with new repository 
	            fail("Should not be able to delete non-empty directory");
            } catch (DatabaseAccessException expected) { /* expected */ }
            for (int j=0; j < l; j++) {
                String entry = entries[j];
                rdsa.delete(entry, NOFORCE);
                assertTrue(entry + " should not exist anymore", !rdsa.exists (entry));
            }
			rdsa.delete(dirName, NOFORCE); // will work with new repository
        }
    }

	/**
	 * Test the getProperties Method.
	 */
    public void testProperties () throws Exception {

        RepositoryDataSourceAdaptor rdsa = this.getNewRepositoryDSA ();
        
        rdsa.createEntry("", "infoEntry", getInputStream());
        rdsa.putEntry       ("infoEntry", getInputStream());
        rdsa.unlock         ("infoEntry");  // Release Rv. 1
        rdsa.lock           ("infoEntry");  
        rdsa.putEntry       ("infoEntry", getInputStream());
        
        // Our "current" user is null but RDSA uses guest as default so this is OK
        String[] versions = rdsa.getVersions("infoEntry");
        assertEquals(1, versions.length);
        
        rdsa.unlock         ("infoEntry");  // Release Rv. 2
        versions = rdsa.getVersions("infoEntry");
        assertEquals(2, versions.length);
        for (int i = 2; i > 0; i--) {
            assertEquals(Integer.toString(i), versions[2-i]);
        }

        DataObject theObject = rdsa.getProperties("infoEntry");
        assertNotNull(theObject);

        theObject = rdsa.getProperties("infoEntry", "2");
        assertNotNull(theObject);

        rdsa.createContainer("", "infoDir");
        theObject = rdsa.getProperties("infoDir");
        assertNotNull(theObject);

		this.cleanup(rdsa, "infoEntry", "infoDir");
    }

    /**
     * Test deletion of entries versus the attic.
     */
    public void testDelete () throws Exception {

        RepositoryDataSourceAdaptor rdsa = this.getNewRepositoryDSA ();
        
        rdsa.createEntry("", "deleteEntry", getInputStream());  // Rev 1
        rdsa.putEntry       ("deleteEntry", getInputStream());  // Still, Rev 1
        rdsa.unlock         ("deleteEntry");
        rdsa.delete         ("deleteEntry", NOFORCE);                    // Rev 2
        rdsa.createEntry("", "deleteEntry", getInputStream());  // Rev 3
        rdsa.unlock         ("deleteEntry");
        
        rdsa.getProperties("deleteEntry");
		InputStream in1 = getInputStream();
		try {
			InputStream in2 = rdsa.getEntry("deleteEntry");
			try {
				assertTrue(FileUtilities.equalsStreamContents(in1, in2));
			} finally {
				in2.close();
			}
		} finally {
			in1.close();
		}

		InputStream in11 = getInputStream();
		try {
			InputStream in2 = rdsa.getEntry("deleteEntry", "1");
			try {
				assertTrue(FileUtilities.equalsStreamContents(in11, in2));
			} finally {
				in2.close();
			}
		} finally {
			in11.close();
		}  

        // This must fail since there is no second revision
        try
        {
            InputStream in12 = getInputStream();
			try {
				InputStream in2 = rdsa.getEntry("deleteEntry", "2");
				try {
					assertTrue(FileUtilities.equalsStreamContents(in12, in2));
				} finally {
					in2.close();
				}
			} finally {
				in12.close();
			}
            fail("This version should not exists");
        }
        catch (DatabaseAccessException expected) { /* expected */ }

		this.cleanup(rdsa, "deleteEntry");
    }

    /**
     * Test if a getParent() is working, even when there is no file for the
     * current object.
     */
	public void testGetParent() throws DatabaseAccessException {

        RepositoryDataSourceAdaptor theAdaptor = this.getNewRepositoryDSA ();

        assertEquals ("some/lenghty/path",
                           theAdaptor.getParent ("some/lenghty/path/blubber.html"));
        assertEquals ("",
                           theAdaptor.getParent ("a_top_level_name"));
        assertNull (  theAdaptor.getParent (""));
    }

    /**
     * Test if a getName() is working, even when there is no file for the
     * current object.
     */
	public void testGetName() throws DatabaseAccessException {
        RepositoryDataSourceAdaptor theAdaptor = this.getNewRepositoryDSA ();
        String                       theName    = "blubber.html";

        assertEquals (theName,
                      theAdaptor.getName ("does/not/matter/" + theName));
        assertEquals (theName,
                      theAdaptor.getName (theName));
    }

    /**
     * Test if all Sorts of Events are generated.
     */
    public void testEvents () throws DatabaseAccessException,IOException {
        
        RepositoryDataSourceAdaptor rdsa = this.getNewRepositoryDSA ();
        rdsa.setProtocol("t");
        rdsa.addDataChangeListener(this);
        DataChangeEvent le;
        
		events = new Stack<>(); // Start Tracking Events
        
        rdsa.createEntry("", "anEntry", getInputStream());
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_CREATED,  le.getChangeMode());
        assertEquals("t://anEntry",      le.getMessage());

        rdsa.putEntry("anEntry", getInputStream());
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_MODIFIED,  le.getChangeMode());
        assertEquals("t://anEntry",      le.getMessage());

        rdsa.getEntryOutputStream("anEntry").close();
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_MODIFIED,  le.getChangeMode());
        assertEquals("t://anEntry",      le.getMessage());
        rdsa.unlock("anEntry");
        
        rdsa.delete("anEntry", NOFORCE);
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_DELETED,  le.getChangeMode());
        assertEquals("t://anEntry",     le.getMessage());
        
        rdsa.createEntry("", "anEntry", getInputStream());
        getLastEvent();
        rdsa.unlock("anEntry");

        rdsa.createContainer("", "aDir");
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_CREATED,  le.getChangeMode());
        assertEquals("t://aDir",            le.getMessage());
        
        rdsa.delete("aDir", NOFORCE);
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_DELETED,  le.getChangeMode());
        assertEquals("t://aDir",            le.getMessage());

        rdsa.removeDataChangeListener(this);
    
        events = null;   // Stop Tracking Events

		this.cleanup(rdsa, "anEntry");
    }

    /**
     * Test if operations are correctly suppressed by event handlers.
     */
    public void testDisAllow() throws DatabaseAccessException,IOException {
        try {
            RepositoryDataSourceAdaptor rdsa = this.getNewRepositoryDSA ();
            rdsa.addDataChangeListener(this);
            
            allow = false;
            try {
                rdsa.createEntry("", "allowEntry", getInputStream());
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }
            
            try {
                rdsa.createEntry("", "allowEntry").close();
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }
            
            allow = true;
            rdsa.createEntry("", "allowEntry", getInputStream());
            rdsa.unlock         ("allowEntry");
            allow = false;

            try {
                rdsa.putEntry("allowEntry", getInputStream());
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }

            try {
                rdsa.getEntryOutputStream("anEntry").close();
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }
            
            try {
                rdsa.delete("allowEntry", NOFORCE);
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }

            allow = true;
            rdsa.delete("allowEntry", NOFORCE);
            allow = false;

            try {
                rdsa.createContainer("", "eventDir");
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }
            
            allow = true;
            rdsa.createContainer("", "eventDir");
            allow = false;

            try {
                rdsa.delete("eventDir", NOFORCE);
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }

            allow = true;
            rdsa.delete("eventDir", NOFORCE);

            rdsa.removeDataChangeListener(this);
        }
        finally {
            allow = true; // don't let this accidently stick to false.
        }
    }

	/**
	 * Get an instance to test. <br/>
	 * It is guaranteed that each call gives a new instance.
	 *
	 * @return the test instance; never null
	 */
	protected RepositoryDataSourceAdaptor getNewRepositoryDSA() {
		RepositoryConfig theRepConfig = TypedConfiguration.newConfigItem(RepositoryConfig.class);
		PropertyDescriptor theDescr = theRepConfig.descriptor().getProperty(Config.REPOSITORY);

		theRepConfig.setImplementationClass(RepositoryDataSourceAdaptor.class);
		theRepConfig.setWorkareaURL("http://not_in_use/");

		theRepConfig.update(theDescr, this.getImplementationConfiguration());
		return SimpleInstantiationContext.CREATE_ALWAYS_FAIL_IMMEDIATELY.getInstance(theRepConfig);
	}

	private void cleanup(RepositoryDataSourceAdaptor rdsa, String... someFiles) throws DatabaseAccessException {
		if (someFiles != null) {
			for (String theFile : someFiles) {
				rdsa.delete(theFile, NOFORCE);

				assertFalse("Failed to delete '" + theFile + "'!", rdsa.exists(theFile));
			}
		}
	}

	/**
	 * Check all properties of DAPropertyNames.
	 * 
	 * Check for consistency.
	 */
    private void checkProperties(RepositoryDataSourceAdaptor aRDSA, String aName, boolean isContainerCheck) throws DatabaseAccessException {
		Object theAttribute;
		DataObject theDataObject = aRDSA.getProperties(aName);

		theAttribute = checkProperty(theDataObject, DAPropertyNames.SIZE, Long.class);
		if (theAttribute != null) {
			// this.checkLongFor0(theAttribute);
		}
		theAttribute = checkProperty(theDataObject, DAPropertyNames.LAST_MODIFIED, Long.class);
		if (theAttribute != null) {
			this.checkLongFor0(theAttribute);
		}
		checkProperty(theDataObject, DAPropertyNames.IS_READABLE, Boolean.class);
		checkProperty(theDataObject, DAPropertyNames.IS_WRITEABLE, Boolean.class);
		theAttribute = checkProperty(theDataObject, DAPropertyNames.IS_ENTRY, Boolean.class);
		if (theAttribute != null && theAttribute instanceof Boolean) {
			boolean theBool = ((Boolean) theAttribute).booleanValue();
			assertEquals(theBool, !isContainerCheck);
		}
		theAttribute = checkProperty(theDataObject, DAPropertyNames.IS_CONTAINER, Boolean.class);
		if (theAttribute != null && theAttribute instanceof Boolean) {
			boolean theBool = ((Boolean) theAttribute).booleanValue();
			assertEquals(theBool, isContainerCheck);
		}
		theAttribute = checkProperty(theDataObject, DAPropertyNames.EXISTS, Boolean.class);
		if (theAttribute != null && theAttribute instanceof Boolean) {
			boolean theBool = ((Boolean) theAttribute).booleanValue();
			assertTrue(theBool);
		}
		theAttribute = checkProperty(theDataObject, DAPropertyNames.NAME, String.class);

		checkProperty(theDataObject, DAPropertyNames.NUM_VERSIONS, Integer.class);
		theAttribute = checkProperty(theDataObject, DAPropertyNames.LOCKED, Boolean.class);
		if (theAttribute != null && theAttribute instanceof Boolean) {
			boolean theBool = ((Boolean) theAttribute).booleanValue();
			if (theBool) {
				checkProperty(theDataObject, DAPropertyNames.LOCKER, String.class);
			}
		}
		theAttribute = checkProperty(theDataObject, DAPropertyNames.DELETED, Boolean.class);
		if (theAttribute != null && theAttribute instanceof Boolean) {
			boolean theBool = ((Boolean) theAttribute).booleanValue();
			assertTrue(!theBool);
		}
		checkProperty(theDataObject, DAPropertyNames.AUTHOR, String.class);
    }

    /**
     * check whether <code>getAttribute()</code> returns the expected type.
     * 
     * @return the Object retrieved, for further testing.
     */
	private Object checkProperty(DataObject aDataObject, String anAttributeName, Class<?> anExpectedClass) {
		Object theAttribute = null;
		try {
            theAttribute = aDataObject.getAttributeValue(anAttributeName);
            if (theAttribute != null){
            	assertTrue(theAttribute.getClass().isAssignableFrom(anExpectedClass));	
            }
            else {
            	System.out.println("Attribute '" + anAttributeName + "' is null");
            }
        } catch (NoSuchAttributeException ignored) { /* ignored */ }
		return theAttribute;
			
	}
	
	/**
	 * Check if the value of the given object is null. The type of the given object has to be
	 * java.lang.String
	 * 
	 * @param anObject
	 *        Object to be checked to be a long.
	 */
	private void checkLongFor0(Object anObject){
		if (anObject instanceof Long){
			assertFalse("Value should be other than 0l!", Long.valueOf(0l).equals(anObject));
		}
	}
}
