/*
 * SPDX-FileCopyrightText: 2022 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.kafka.log;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.util.Iterator;
import java.util.UUID;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.header.Header;
import org.apache.kafka.common.header.Headers;

import com.top_logic.basic.Logger;
import com.top_logic.basic.StringServices;
import com.top_logic.basic.logging.LogUtil;
import com.top_logic.basic.xml.TagWriter;

/**
 * Utility methods for logging in the Kafka binding.
 * 
 * @see LogUtil
 * 
 * @author <a href=mailto:jst@top-logic.com>Jan Stolzenburg</a>
 */
public class KafkaLogUtil {

	/**
	 * The name of the header in which the unqiue id generated by <i>TopLogic</i> is sent.
	 * <p>
	 * The name starts with "tl" to avoid conflicts with other headers from other software.
	 * </p>
	 */
	public static final String MESSAGE_ID_HEADER = "tl-message-id";

	private static final String HOST_ADDRESS = lookupHostAddress();

	/**
	 * Attach a unique id to the record.
	 * <p>
	 * The id is used for analyzing the logs across systems. It is logged on the sending system and
	 * on each receiving system. That makes it trivial to find out which log messages are about the
	 * same message.
	 * </p>
	 */
	public static UUID attachId(ProducerRecord<?, ?> record) {
		UUID id = UUID.randomUUID();
		record.headers().add(MESSAGE_ID_HEADER, id.toString().getBytes(StandardCharsets.UTF_8));
		return id;
	}

	/**
	 * Returns the {@link #MESSAGE_ID_HEADER} as a readable {@link String}, if there is one.
	 * <p>
	 * Returns the empty {@link String} otherwise.
	 * </p>
	 */
	public static String toStringTLMessageId(Headers headers) {
		Iterator<Header> idHeaders = headers.headers(MESSAGE_ID_HEADER).iterator();
		if (!idHeaders.hasNext()) {
			return "";
		}
		byte[] valueBytes = idHeaders.next().value();
		String valueText = new String(valueBytes, StandardCharsets.UTF_8);
		if (idHeaders.hasNext()) {
			/* The rest will be written out generically when all headers are being written. */
			String message = "Record with multiple " + MESSAGE_ID_HEADER + " headers.";
			Logger.error(message, KafkaLogUtil.class);
		}
		return " " + valueText;
	}

	private static String lookupHostAddress() {
		try {
			InetAddress localHost = InetAddress.getLocalHost();
			return localHost.getCanonicalHostName() + " (" + localHost.getHostAddress() + ")";
		} catch (UnknownHostException exception) {
			Logger.error("Failed to get the local host: " + exception.getMessage(), exception);
			return "[UNKNOWN HOST]";
		}
	}

	/**
	 * The canonical host name and ip address.
	 * <p>
	 * The value is looked up only once, when the application start. It could change afterwards. But
	 * that is ignored here, as servers usually don't change their network connection while they are
	 * running.
	 * </p>
	 */
	public static String getHostAddress() {
		return HOST_ADDRESS;
	}

	/**
	 * Writes the value in the specified tag.
	 * <p>
	 * null is treated as the empty {@link String}: Only the tag itself is written.
	 * </p>
	 */
	public static void writeTextTag(TagWriter output, String tagName, Object value) {
		output.beginTag(tagName);
		if (value != null) {
			if (value.getClass().isArray()) {
				/* Don't call toString() on an array, as it does not print the content. */
				output.writeText(StringServices.debugValue(value));
			} else {
				output.writeText(value.toString());
			}
		}
		output.endTag(tagName);
	}

}
