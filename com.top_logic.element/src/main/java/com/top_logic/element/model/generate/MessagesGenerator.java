/*
 * SPDX-FileCopyrightText: 2008 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.element.model.generate;

import static com.top_logic.model.util.TLModelNamingConvention.*;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

import com.top_logic.basic.generate.FileGenerator;
import com.top_logic.basic.generate.PropertiesFile;
import com.top_logic.basic.util.ResKey;
import com.top_logic.model.ModelKind;
import com.top_logic.model.TLClassifier;
import com.top_logic.model.TLEnumeration;
import com.top_logic.model.TLModule;
import com.top_logic.model.TLStructuredType;
import com.top_logic.model.TLStructuredTypePart;
import com.top_logic.model.TLType;
import com.top_logic.model.util.TLModelNamingConvention;

/**
 * {@link FileGenerator} that creates internationalization properties.
 * 
 * @author <a href="mailto:bhu@top-logic.com">Bernhard Haumacher</a>
 */
public class MessagesGenerator extends FileGenerator {

	private static final String MISSING_PREFIX = "[missing:";

	private static final String MISSING_SUFFIX = "]";

	private final CharsetEncoder _encoder = Charset.forName("ISO_8859-1").newEncoder();

	private final String _language;

	private final File _resourceDir;

	private final Properties _oldValues = new Properties();

	private final TLModule _module;

	/**
	 * Creates a new {@link MessagesGenerator}.
	 * 
	 * @param resourceDir
	 *        Directory containing the resources.
	 * @param language
	 *        Language to generate I18N file for.
	 * @param module
	 *        {@link TLModule} to generate internationalisation file for.
	 * @throws IOException
	 *         Iff loading of former resource file failed.
	 */
	public MessagesGenerator(File resourceDir, String language, TLModule module) throws IOException {
		super(PropertiesFile.INSTANCE);
		_module = module;
		_language = language;
		_resourceDir = resourceDir;

		loadOldValues();
	}

	@Override
	protected Charset getEncoding() {
		return Charset.forName("ISO-8859-1");
	}

	/**
	 * The properties read from the existing file.
	 */
	public Properties getOldValues() {
		return _oldValues;
	}

	/**
	 * Loads old value from an existing messages file of the same name.
	 */
	protected void loadOldValues() throws IOException {
		File oldFile = new File(this._resourceDir, fileName());
		if (oldFile.exists()) {
			Properties lastValues = loadValues(oldFile, new Properties());
			dropMissing(lastValues);
			_oldValues.putAll(lastValues);
		}
	}

	private Properties loadValues(File file, Properties target) throws IOException {
		try {
			try (FileInputStream in = new FileInputStream(file)) {
				target.load(in);
				return target;
			}
		} catch (IOException e) {
			throw new IOException("Reading old contents for '" + file.getAbsolutePath() + "' failed.", e);
		}
	}

	private void dropMissing(Properties values) {
		for (Iterator<Object> it = values.values().iterator(); it.hasNext();) {
			String value = (String) it.next();

			if (value.startsWith(MISSING_PREFIX) && value.endsWith(MISSING_SUFFIX)) {
				it.remove();
			}
		}
	}

	@Override
	public String fileName() {
		return TLModelNamingConvention.resourcesFileName(_module, _language);
	}

	@Override
	protected void writeContents() {
		commentStart();
		commentLine("Internationalization for all types in module '" + _module.getName() + "'");
		commentLine("");
		commentLine("@author Automatically generated by <code>" + this.getClass().getName() + "</code>");
		commentStop();

		Set<String> usedKeys = new HashSet<>();

		ResKey moduleKey = getModuleLabelKey(_module);
		writeKey(moduleKey, usedKeys);
		for (TLType type : _module.getTypes()) {
			if (type.getModelKind() == ModelKind.ASSOCIATION) {
				// Skip since these are almost all only technical ones.
				continue;
			}

			commentStart();
			commentLine("Internationalization for type '" + type.getName() + "'");
			commentStop();

			writeKey(resourceKey(type), usedKeys);
			nl();

			if (type instanceof TLEnumeration) {
				for (TLClassifier part : ((TLEnumeration) type).getClassifiers()) {
					ResKey resourceKey = resourceKey(part);
					writeKey(resourceKey, usedKeys);
				}
			} else if (type instanceof TLStructuredType) {
				for (TLStructuredTypePart part : ((TLStructuredType) type).getLocalParts()) {
					ResKey resourceKey = resourceKey(part);
					if (part.isOverride() && existing(resourceKey) == null) {
						continue;
					}
					writeKey(resourceKey, usedKeys);
				}
			}
		}

		writeAdditionalKeys(usedKeys);
	}

	private void writeAdditionalKeys(Set<String> usedKeys) {
		for (Entry<Object, Object> entry : _oldValues.entrySet()) {
			if (usedKeys.contains(entry.getKey())) {
				// Key already written.
				continue;
			}
			line((String) entry.getKey(), (String) entry.getValue());
		}
	}

	private void writeKey(ResKey key, Set<String> usedKeys) {
		String existingKey = existing(key);
		if (existingKey != null) {
			usedKeys.add(existingKey);
		}
		String canonicalKey = canonical(key);
		String value = getValue(canonicalKey, existingKey);

		line(canonicalKey, value);
	}

	private String canonical(ResKey key) {
		ResKey direct = key.direct();
		String canonicalKey = direct.getKey();
		return canonicalKey;
	}

	private String existing(ResKey key) {
		if (!key.hasKey()) {
			return null;
		}
		ResKey direct = key.direct();
		String directKey = direct.getKey();
		if (hasValue(directKey)) {
			return directKey;
		}
		ResKey fallback = key.fallback();
		if (fallback != null) {
			return existing(fallback);
		}
		return null;
	}

	private void line(String key, String value) {
		String newValue = replaceLineBreaks(value);
		line(encodeUnicode(key) + " = " + encodeUnicode(newValue));
	}

	private String encodeUnicode(String value) {
		if (!_encoder.canEncode(value)) {
			StringBuilder buffer = new StringBuilder();
			for (int n = 0, cnt = value.length(); n < cnt; n++) {
				char ch = value.charAt(n);
				if (_encoder.canEncode(ch)) {
					buffer.append(ch);
				} else {
					buffer.append("\\u");
					String encoding = Integer.toHexString(ch).toUpperCase();
					for (int k = encoding.length(); k < 4; k++) {
						buffer.append('0');
					}
					buffer.append(encoding);
				}
			}
			value = buffer.toString();
		}
		return value;
	}

	private String replaceLineBreaks(String value) {
		// Normalize
		return value.replaceAll("\\r?\\n", "\\\\n");
	}

	private String getValue(String canonicalKey, String existingKey) {
		String oldValue = existingKey != null ? getValue(existingKey) : null;
		String value;
		if (oldValue != null) {
			value = oldValue;
		} else {
			value = getMissingValue(canonicalKey);
		}
		return value;
	}

	private String getMissingValue(String key) {
		return MISSING_PREFIX + key + MISSING_SUFFIX;
	}

	/**
	 * Whether a value is assigned for the given model-related key.
	 */
	protected boolean hasValue(String directKey) {
		return _oldValues.containsKey(directKey);
	}

	/**
	 * The existing value for the given model-related key.
	 */
	protected String getValue(String existingKey) {
		return (String) _oldValues.get(existingKey);
	}
}
