/*
 * SPDX-FileCopyrightText: 2015 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.basic.config;

import java.util.Arrays;

import com.top_logic.basic.ConfigurationError;
import com.top_logic.basic.StringServices;
import com.top_logic.basic.config.annotation.DerivedRef;
import com.top_logic.basic.config.annotation.Ref;
import com.top_logic.basic.config.annotation.Step;
import com.top_logic.basic.config.misc.PropertyValue;
import com.top_logic.basic.config.misc.PropertyValueImpl;
import com.top_logic.basic.tools.NameBuilder;

/**
 * A path of property names in a {@link ConfigurationItem}.
 * 
 * <p>
 * Such path can be {@link #resolve(ConfigurationItem) resolved} on a base item resulting in the
 * evaluation of all properties in the path on the value produced by the preceding evaluation.
 * </p>
 * 
 * @author <a href="mailto:jst@top-logic.com">Jan Stolzenburg</a>
 */
public final class NamePath {

	private final PathStep[] _steps;

	/**
	 * Creates {@link NamePath} for a list of {@link PathStep}s.
	 * 
	 * @param steps
	 *        {@link PathStep}s to evaluate.
	 */
	public NamePath(PathStep[] steps) {
		_steps = steps;
	}

	private static PathStep[] steps(Step[] stepAnnotations) {
		PathStep[] result = new PathStep[stepAnnotations.length];
		int index = 0;
		for (Step stepAnnotation : stepAnnotations) {
			result[index++] = step(stepAnnotation);
		}
		return result;
	}

	private static PathStep step(Step stepAnnotation) {
		Class<?> type = stepAnnotation.type();
		if (type == Void.class) {
			// The default meaning "no explicit type".
			type = null;
		}
		return new PathStep(type, stepAnnotation.value());
	}

	private static PathStep[] steps(String[] names) {
		PathStep[] result = new PathStep[names.length];
		int index = 0;
		for (String stepName : names) {
			result[index++] = new PathStep(null, stepName);
		}
		return result;
	}

	/**
	 * The size of this path. Always >=0.
	 */
	public int size() {
		return _steps.length;
	}

	/**
	 * Index has to be >=0 and < size().
	 * 
	 * @return Never null.
	 */
	public PathStep get(int index) {
		return _steps[index];
	}

	/**
	 * A new copy of the internally used array. Never null. Never contains null.
	 */
	public PathStep[] toArray() {
		return _steps.clone();
	}

	/**
	 * Generated by Eclipse
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(_steps);
		return result;
	}

	/**
	 * Generated by Eclipse
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		NamePath other = (NamePath) obj;
		if (!Arrays.equals(_steps, other._steps)) {
			return false;
		}
		return true;
	}

	@Override
	public String toString() {
		return new NameBuilder(this).add("steps", Arrays.toString(_steps)).buildName();
	}

	/**
	 * Access to the given property value independent of the fact whether the property is mandatory
	 * but not set.
	 */
	public static Object value(ConfigurationItem model, PropertyDescriptor property) {
		if (property.isMandatory() && !model.valueSet(property)) {
			return null;
		}
		return model.value(property);
	}

	/**
	 * Short-cut for crating a {@link NamePath} and {@link #resolve(ConfigurationItem) resolving} it
	 * based on the given item.
	 */
	public static PropertyValue resolve(Ref ref, ConfigurationItem base) {
		return path(ref).resolve(base);
	}

	/**
	 * Creates a {@link NamePath} for the given {@link Ref} annotation.
	 *
	 * @param ref
	 *        The annotated path.
	 */
	public static NamePath path(Ref ref) {
		return path(ref.steps(), ref.value());
	}

	/**
	 * Creates a {@link NamePath} for the given {@link Ref} annotation.
	 *
	 * @param ref
	 *        The annotated path.
	 */
	public static NamePath path(DerivedRef ref) {
		return path(ref.steps(), ref.value());
	}

	private static NamePath path(Step[] steps, String[] stepNames) {
		PathStep[] path;
		if (steps.length == 0) {
			path = steps(stepNames);
		} else {
			path = steps(steps);
		}
		return new NamePath(path);
	}

	/**
	 * Resolves the value of this path expression based on the given item.
	 * 
	 * <p>
	 * The first property is evaluated on the given item. Each following property in this path is
	 * evaluated on the result of the preceding evaluation.
	 * </p>
	 * 
	 * @param base
	 *        The {@link ConfigurationItem} to evaluate the first property in this path on.
	 * @return A reference to the last property of the last item produced by evaluating this
	 *         {@link NamePath}.
	 */
	public PropertyValue resolve(ConfigurationItem base) {
		PathStep[] path = _steps;
		if (path.length == 0) {
			throw new IllegalArgumentException("Invalid dependency path of length zero specified.");
		}
		for (int n = 0, cnt = path.length - 1; n < cnt; n++) {
			PathStep step = path[n];
			PropertyDescriptor refProperty = step.resolve(base.descriptor());

			if (!ConfigurationItem.class.isAssignableFrom(refProperty.getType())) {
				throw new IllegalArgumentException(
					"A property path must consist only of item-valued properties, property '"
						+ refProperty + "' is not. It is declared as: " + refProperty.getType());
			}

			base = (ConfigurationItem) value(base, refProperty);

			if (base == null) {
				return null;
			}
		}
		PropertyDescriptor targetProperty = path[path.length - 1].resolve(base.descriptor());

		return new PropertyValueImpl(base, targetProperty);
	}

	/**
	 * A single step in a {@link NamePath}.
	 */
	public static class PathStep {
		private final Class<?> _configType;
	
		private final String _propertyName;
	
		public PathStep(Class<?> configType, String propertyName) {
			assert !StringServices.isEmpty(propertyName) : "Step name must not be null or empty.";

			_configType = configType;
			_propertyName = propertyName;
		}
	
		public Class<?> getConfigType() {
			return _configType;
		}
	
		public String getPropertyName() {
			return _propertyName;
		}
	
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((_configType == null) ? 0 : _configType.hashCode());
			result = prime * result + ((_propertyName == null) ? 0 : _propertyName.hashCode());
			return result;
		}
	
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			PathStep other = (PathStep) obj;
			if (_configType == null) {
				if (other._configType != null)
					return false;
			} else if (!_configType.equals(other._configType))
				return false;
			if (_propertyName == null) {
				if (other._propertyName != null)
					return false;
			} else if (!_propertyName.equals(other._propertyName))
				return false;
			return true;
		}
	
		@Override
		public String toString() {
			return _propertyName;
		}
	
		public PropertyDescriptor resolve(ConfigurationDescriptor contextDescriptor) {
			ConfigurationDescriptor descriptor;
	
			Class<?> explicitType = getConfigType();
			if (explicitType != null) {
				// Explicitly given - like a type cast in the path.
				descriptor = TypedConfiguration.getConfigurationDescriptor(explicitType);
			} else {
				descriptor = contextDescriptor;
			}
			return property(descriptor, getPropertyName());
		}
	
		private static PropertyDescriptor property(ConfigurationDescriptor descriptor, String name) {
			PropertyDescriptor property = descriptor.getProperty(name);
			if (property == null) {
				throw new ConfigurationError("No such property '" + name + "' in descriptor '" + descriptor
					+ "'.");
			}
			return property;
		}

	}

}
