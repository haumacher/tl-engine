/*
 * SPDX-FileCopyrightText: 2000 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package test.com.top_logic.dsa.file;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

import junit.framework.Test;
import junit.framework.TestSuite;

import test.com.top_logic.dsa.DSATestSetup;
import test.com.top_logic.dsa.TestDataSourceAdapter;

import com.top_logic.basic.FileManager;
import com.top_logic.basic.Logger;
import com.top_logic.basic.config.PolymorphicConfiguration;
import com.top_logic.basic.config.SimpleInstantiationContext;
import com.top_logic.basic.config.TypedConfiguration;
import com.top_logic.basic.io.FileUtilities;
import com.top_logic.basic.tooling.ModuleLayoutConstants;
import com.top_logic.dob.DataObject;
import com.top_logic.dob.ex.NoSuchAttributeException;
import com.top_logic.dsa.DAPropertyNames;
import com.top_logic.dsa.DataSourceAdaptor;
import com.top_logic.dsa.DatabaseAccessException;
import com.top_logic.dsa.evt.DataChangeEvent;
import com.top_logic.dsa.evt.DataChangeListener;
import com.top_logic.dsa.ex.DataChangeException;
import com.top_logic.dsa.ex.NotSupportedException;
import com.top_logic.dsa.file.FileManagerDataSourceAdaptor;
import com.top_logic.dsa.file.FilesystemDataSourceAdaptor;
import com.top_logic.dsa.file.FilesystemDataSourceAdaptor.Config;

/**
 * Testcase for the {@link com.top_logic.dsa.file.FilesystemDataSourceAdaptor}.
 */
public class TestFilesystemDataSourceAdaptor extends TestDataSourceAdapter implements DataChangeListener {
	
    /** DemoData used for Streaming */
    public static final byte DATA[] = 
		("This is some Data generated by " + TestFilesystemDataSourceAdaptor.class.getName()).getBytes();

    /** Array of names known to have problems */
    public static final String NAMES[] =  {
            "Test Name",
            "TestName",
            "_name_with_underscores_",
            "_^!$%&)(][}{=` +~'#,.-_",
            "~$name with Tilde and Dollar~",
            "~name with Tilde~"
            /*
             // This will not work in Solaris °, §, ´ are no ascii characters
            "_°^!§$%&)(][}{=` ´+~'#,.-_",
             // This will not work in NT or Unix due to / \ resp. ;
            " °^!\"§$%&/)(][}{=?\\`´*+~'#,.;:-_|><"
            */
        };

    /** Array of names als List */
    public static final List NAMESL = Arrays.asList(NAMES);

	private static final boolean NOFORCE = false;

    /** Last event we got via the DataChangeListener interface */
    protected Stack events = new Stack();
    
    /** Result returned by checkChangeAllow for Testing */
    protected boolean           allow = true;

    /**
     * Default constructor.
     *
     * @param name of test to execute.
     */
    public TestFilesystemDataSourceAdaptor (String name) {
        super (name);
    }
    
	@Override
	protected void setUp() throws Exception {
		super.setUp();
		File dir = new File("tmp/FDSA");
		assertTrue("Unable to create directory " + dir, dir.mkdir());
	}

	@Override
	protected void tearDown() throws Exception {
		FileUtilities.deleteR(new File("tmp/FDSA"));
		super.tearDown();
	}

    /** 
     * Create an instance of FilesystemDataSourceAdaptor pointing to the TMP-directory.
     * 
	 * @see test.com.top_logic.dsa.TestDataSourceAdapter#getInstance()
	 */
	@Override
	protected DataSourceAdaptor getInstance() throws DatabaseAccessException {
		return new FilesystemDataSourceAdaptor("./tmp/");
	}   
    
    /** 
	 * Always "test.txt".
	 */
	@Override
	protected String getValidEntryName() {
		return "test.txt";
	}

	/** Create an InputStream with some demo-Data */
    @Override
	protected InputStream getInputStream() {
        return new ByteArrayInputStream(DATA);
    }

    /** 
     * Just Record the Event for later checking.
     */
    @Override
	public void dataChanged (DataChangeEvent anEvent)  {
        if (events != null)
            events.push(anEvent);
    }

    /**
     * This method will be called before the change of data will be done.
     *
     * If, and only if, no listener is throwing an exception, the change 
     * will be allowed and executed. This method is needed, if the changes 
     * in the system will affect securiy reasons.
     *
     * @param    anEvent                The event holding the information
     *                                  about the change.
     * @throws   DataChangeException    Thrown, when the change is not allowed,
     *                                  the contained message should explain
     *                                  the reason.
     */
    @Override
	public void checkChangeAllow (DataChangeEvent anEvent) 
        throws DataChangeException {
        if (!allow)
            throw new DataChangeException("Not allowed (Testing)");
    }
    
    /** Return the Last Event and Clear it meanwhile */ 
    protected DataChangeEvent getLastEvent() {
        return (DataChangeEvent) events.pop();
    }
    
    /**
     * Pseudo test to cleanup the tmp directory
     */
    public void cleanupTmp ()  {
    	deleteTestDir();
    	
        createdCleanTestDir("repository");
        createdCleanTestDir("workarea");
    }

    // actual TestMethods start here

    /**
     * test Main functions of the dsa...
     */
    public void testMain () throws DatabaseAccessException {
		FilesystemDataSourceAdaptor fdsa = new FilesystemDataSourceAdaptor("./tmp/FDSA");
        
        assertTrue(!fdsa.isRepository());
        int l = NAMES.length;
                
        // Create directories
        for (int i=0; i < l; i++) {
            String dirName  = NAMES[i];
            String xDirName = fdsa.createContainer("", dirName);
            assertTrue(!xDirName.endsWith(File.separator));
            assertTrue(!xDirName.endsWith("/")); 
            assertEquals(xDirName, fdsa.getName(dirName));
            this.checkProperties(fdsa, xDirName, true);
            for (int j=0; j < l; j++) 
            {
                String fileName  = NAMES[j];
                String xFileName = fdsa.createEntry(dirName, fileName, getInputStream());
				this.checkProperties(fdsa, xFileName, false);
                assertTrue(fdsa.isEntry     (xFileName));
                assertTrue(!fdsa.isContainer(xFileName));

                assertEquals(fileName,  fdsa.getName  (xFileName));
                assertEquals(xDirName,  fdsa.getParent(xFileName));

                assertTrue(fdsa.isEntry     (xFileName));
                assertTrue(!fdsa.isContainer(xFileName));
                assertEquals(fileName,  fdsa.getName (xFileName));
                assertEquals(xDirName,  fdsa.getParent(xFileName));

                assertEquals(xFileName, fdsa.getPath(xFileName));
                assertEquals(xFileName, fdsa.getChild(xDirName,fileName));
                
                assertTrue(fdsa.exists(xFileName));
                
                String tmpName    = fdsa.createNewEntryName(xDirName, "xxx", null);
                String tmpPath    = xDirName + '/' + tmpName;
                fdsa.rename(xFileName, tmpName);
                assertTrue(!fdsa.exists(xFileName));
                assertTrue(fdsa.exists(tmpPath));
                assertTrue(!tmpName.equals(fdsa.createNewEntryName(xDirName, "xxx", null)));
                fdsa.rename(tmpPath, fileName);
                assertTrue(fdsa.exists(xFileName));
                
                // What is the expected format for this value ???
                // String url = fdsa.getURL(xFileName);
            }
            assertTrue(dirName + " must exist"      , fdsa.exists      (dirName));
            assertTrue(dirName + " must be container", fdsa.isContainer (dirName));
            assertTrue(dirName + " must NOT be Entry",!fdsa.isEntry    (dirName));
            
            // What is the expected format for this value ???
            // url = fdsa.getURL(dirName);
            
            assertEquals(dirName, fdsa.getPath(dirName));
            
            String entries[] = fdsa.getEntryNames(dirName);
            assertEquals(l , entries.length);
            for (int j=0; j < l; j++) {
                String entryName = fdsa.getName (entries[j]);
                assertTrue(entryName + " not found ", NAMESL.contains(entryName));
            }
        }
        
        // Delete all the directories again
        fdsa.deleteRecursively("");
        for (int i=0; i < l; i++) {
            String dirName  = NAMES[i];
            assertTrue(!fdsa.exists (dirName));
        }
    }

    /**
     * Test getting the differetn Kinds of URLs.
     */
    public void testURLs () throws DatabaseAccessException {
		Config config = TypedConfiguration.newConfigItem(FilesystemDataSourceAdaptor.Config.class);
		config.setImplementationClass(FilesystemDataSourceAdaptor.class);
		config.setHome("./tmp/FDSA");

        File webDir = new File("tmp/FDSA-WEB");
              webDir.mkdir();
				DataSourceAdaptor fdsa = newFDSA(config);
        try {
            fdsa.getURL("");
            fail("Expected NotSupportedException");
        } catch (NotSupportedException expected) { /* expected */ }
 
        try {
            fdsa.getForwardURL("");
            fail("Expected NotSupportedException");
        } catch (NotSupportedException expected) { /* expected */ }
        
        // Simluate a FDSA as subdirectory in a WebApplication
        config.setURLPrefix("/tl-dsa/files/");
        config.setRedirectPrefix("/files/");

		fdsa = newFDSA(config);
        assertEquals("/tl-dsa/files/index.html", fdsa.getURL("index.html"));
        assertEquals("/files/index.html"       , fdsa.getForwardURL("index.html"));

        // Simulate a FDSA as subdirectory in a clustered WebApplication
		config.setWebRoot("./tmp/FDSA-WEB");
        
        fdsa = newFDSA(config);
        fdsa.createEntry("", "webEntry.txt", getInputStream());

		fdsa = newFDSA(config);
        assertEquals("/tl-dsa/files/webEntry.txt", fdsa.getURL("webEntry.txt"));
        assertEquals("/files/webEntry.txt"       , fdsa.getForwardURL("webEntry.txt"));
        assertTrue(new File(webDir, "webEntry.txt").exists());
    }

	private DataSourceAdaptor newFDSA(PolymorphicConfiguration<? extends DataSourceAdaptor> config) {
		return SimpleInstantiationContext.CREATE_ALWAYS_FAIL_IMMEDIATELY.getInstance(config);
	}

    /**
     * Test getObjectEntry via the DOImporter.
     */
    public void testObjectEntry () throws DatabaseAccessException {
        
		FilesystemDataSourceAdaptor fdsa = new FilesystemDataSourceAdaptor("./" + ModuleLayoutConstants.SRC_TEST_DIR);
        DataObject theDO = fdsa.getObjectEntry("test/com/top_logic/dsa/file/doData.xml");
        assertNotNull(theDO);
    }
    
    /**
     * Test if all Sorts of Events are generated.
     */
    public void testEvents () throws DatabaseAccessException,IOException {
		FilesystemDataSourceAdaptor fdsa = new FilesystemDataSourceAdaptor("./tmp/FDSA");
        fdsa.setProtocol("t");
        fdsa.addDataChangeListener(this);
        DataChangeEvent le;
        
        events = new Stack();   // Start Tracking Events
        
        fdsa.createEntry("", "anEntry", getInputStream());
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_CREATED  , le.getChangeMode());
        assertEquals("t://anEntry"                  , le.getMessage());

        fdsa.putEntry("anEntry", getInputStream());
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_MODIFIED , le.getChangeMode());
        assertEquals("t://anEntry"                  , le.getMessage());

        fdsa.getEntryOutputStream("anEntry").close();
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_MODIFIED , le.getChangeMode());
        assertEquals("t://anEntry"                  , le.getMessage());
        
        // added by asc
        fdsa.getEntryAppendStream("anEntry").close();
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_MODIFIED , le.getChangeMode());
        assertEquals("t://anEntry"                  , le.getMessage());        

        fdsa.delete("anEntry", NOFORCE);
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_DELETED  , le.getChangeMode());
        assertEquals("t://anEntry"                  , le.getMessage());
        
        fdsa.createEntry("", "anEntry", getInputStream());
        getLastEvent();

        fdsa.deleteRecursively("anEntry");
        le = getLastEvent();
        assertEquals(DataChangeEvent.ENTRY_DELETED  , le.getChangeMode());
        assertEquals("t://anEntry"                  , le.getMessage());

        fdsa.createContainer("", "aDir");
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_CREATED  , le.getChangeMode());
        assertEquals("t://aDir"                         , le.getMessage());
        
        fdsa.delete("aDir", NOFORCE);
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_DELETED,  le.getChangeMode());
        assertEquals("t://aDir",            le.getMessage());

        fdsa.createContainer("", "aDir");
        getLastEvent();
        fdsa.createEntry("aDir", "anEntry", getInputStream());
        getLastEvent();

        fdsa.deleteRecursively("aDir");
        le = getLastEvent();
        assertEquals(DataChangeEvent.CONTAINER_DELETEDREC   , le.getChangeMode());
        assertEquals("t://aDir"                             , le.getMessage());
        
        fdsa.removeDataChangeListener(this);
    
        events = null;   // Stop Tracking Events
    }

    /**
     * Test if Operations are correctly suppressed by Eventhandlers
     */
    public void testDisAllow() throws DatabaseAccessException,IOException {
        try {
			FilesystemDataSourceAdaptor fdsa = new FilesystemDataSourceAdaptor("./tmp/FDSA");
            fdsa.addDataChangeListener(this);
            
            allow = false;
            try {
                fdsa.createEntry("", "anEntry", getInputStream());
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }
            
            try {
                fdsa.createEntry("", "anEntry").close();
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }
            
            allow = true;
            fdsa.createEntry("", "anEntry", getInputStream());
            allow = false;

            try {
                fdsa.putEntry("anEntry", getInputStream());
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            try {
                fdsa.getEntryOutputStream("anEntry").close();
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }
            
            // added by asc
            try {
                fdsa.getEntryAppendStream("anEntry").close();
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            try {
                fdsa.delete("anEntry", NOFORCE);
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            try {
                fdsa.deleteRecursively("anEntry");
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */  }

            allow = true;
            fdsa.delete("anEntry", NOFORCE);
            allow = false;

            try {
                fdsa.createContainer("", "aDir");
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }
            
            allow = true;
            fdsa.createContainer("", "aDir");
            allow = false;

            try {
                fdsa.deleteRecursively("aDir");
                fail("This is not allowed");
            } catch (DataChangeException expected) { /* expected */ }

            allow = true;
            fdsa.deleteRecursively("aDir");

            fdsa.removeDataChangeListener(this);
        }
        finally {
            allow = true; // dont let this accidently stick to false.
        }
    }
    
   /**
    * Check all properties of DAPropertyNames, check for consistence
    */
   private void checkProperties(FilesystemDataSourceAdaptor aFDSA, String aName, boolean isContainerCheck) throws DatabaseAccessException{
	  
	   Object theAttribute;
	   DataObject theDataObject = aFDSA.getProperties(aName);
	   
       checkProperty (theDataObject, DAPropertyNames.SIZE         , Long.class);
	   checkProperty (theDataObject, DAPropertyNames.LAST_MODIFIED, Long.class);
	   checkProperty (theDataObject, DAPropertyNames.IS_READABLE  , Boolean.class);
	   checkProperty (theDataObject, DAPropertyNames.IS_WRITEABLE , Boolean.class);
	   theAttribute = checkProperty (theDataObject, DAPropertyNames.IS_ENTRY, Boolean.class);
	   if (theAttribute != null && theAttribute instanceof Boolean){
			boolean theBool = ((Boolean)theAttribute).booleanValue();
			assertEquals(!isContainerCheck , theBool);
	   }
	   theAttribute = checkProperty (theDataObject, DAPropertyNames.IS_CONTAINER, Boolean.class);
	   if (theAttribute != null && theAttribute instanceof Boolean){
		  boolean theBool = ((Boolean)theAttribute).booleanValue();
		  assertEquals(isContainerCheck, theBool);
	   }
	   theAttribute = checkProperty (theDataObject, DAPropertyNames.EXISTS, Boolean.class);
	   if (theAttribute != null && theAttribute instanceof Boolean){
		   boolean theBool = ((Boolean)theAttribute).booleanValue();
		   assertTrue(theBool);
	   }
	   theAttribute = checkProperty (theDataObject, DAPropertyNames.NAME, String.class);
		
	   checkProperty (theDataObject, DAPropertyNames.NUM_VERSIONS, Integer.class);
	   theAttribute = checkProperty (theDataObject, DAPropertyNames.LOCKED, Boolean.class);
	   if (theAttribute != null && theAttribute instanceof Boolean){
		  boolean theBool = ((Boolean)theAttribute).booleanValue();
		  if (theBool){
			checkProperty (theDataObject, DAPropertyNames.LOCKER, String.class);
		  }
	   }
	   theAttribute = checkProperty (theDataObject, DAPropertyNames.DELETED, Boolean.class);
	   if (theAttribute != null && theAttribute instanceof Boolean){
			boolean theBool = ((Boolean)theAttribute).booleanValue();
			assertTrue(!theBool);
	   }
	   checkProperty (theDataObject, DAPropertyNames.AUTHOR, String.class);    
   }

    /**
     * check whether <code>getAttribute()</code> returns the expected type.
     * 
     * @return the Object retrieved, for further testing.
     */
    private Object checkProperty(DataObject aDataObject, String anAttributeName,
                                 Class anExpectedClass) {
        Object theAttribute = null;
        try {
            theAttribute = aDataObject.getAttributeValue(anAttributeName);
            if (theAttribute != null) {
                assertTrue(
                    theAttribute.getClass().isAssignableFrom(anExpectedClass));
            }
            else {
                System.out.println("Attribute " + anAttributeName + "is null");
            }
        }
        catch (NoSuchAttributeException ignored) { /* ignored */ }

        return theAttribute;

    }
    
    /**
     * Tests if it is possible to append data to the stream.
     *
     */
    public void testEntryAppendStream() throws DatabaseAccessException, IOException {
		FilesystemDataSourceAdaptor fdsa = new FilesystemDataSourceAdaptor("./tmp/FDSA");
        fdsa.setProtocol("t");
        // OutputStream to compare appended data
        ByteArrayOutputStream theOutputStream;
        // InputStream to read the appended data
        
        String theFirstString  = "1234567890";
        String theSecondString = "abcdefghij";
        
        // the String buffer to compare
        StringBuffer theBuffer = new StringBuffer(20);
        theBuffer.append(theFirstString);
        theBuffer.append(theSecondString);
        
        
        // first write
        OutputStream theEntryAppendStream = fdsa.getEntryAppendStream("anEntry");
        theEntryAppendStream.write(theFirstString.getBytes());
        theEntryAppendStream.close();
        
        // second write
        theEntryAppendStream = fdsa.getEntryAppendStream("anEntry");
        theEntryAppendStream.write(theSecondString.getBytes());
        theEntryAppendStream.close();        
        
        // read --> contains both writes?
		InputStream anInputStream = fdsa.getEntry("anEntry");
		try {
			byte[] theBytes = new byte[1];
			theOutputStream = new ByteArrayOutputStream();
			while (anInputStream.read(theBytes) > -1) {
				theOutputStream.write(theBytes);
			}
		} finally {
			anInputStream.close();
		}
        
        assertEquals(theOutputStream.toString(),theBuffer.toString());
        
    }

	public void testGetEntryNames() throws IOException, DatabaseAccessException {
		FileManager fm = FileManager.getInstance();
		List<File> paths = fm.getIDEPaths();
		String subFolderName = getClass().getSimpleName() + "_" + System.currentTimeMillis();
		File f1 = new File(paths.get(0), subFolderName);
		f1.mkdirs();
		File f2 = new File(paths.get(1), subFolderName);
		f2.mkdirs();
		String subFolder = "/" + subFolderName + "/";
		try {
			DataSourceAdaptor fdsa =
				newFDSA(TypedConfiguration.newConfigItem(FileManagerDataSourceAdaptor.Config.class));
			String[] emptyEntries = fdsa.getEntryNames(subFolder);
			assertTrue("Unexpected entries " + Arrays.toString(emptyEntries),
				emptyEntries == null || emptyEntries.length == 0);

			new File(f1, "file1").createNewFile();
			assertEquals(new String[] { subFolder + "file1" }, fdsa.getEntryNames(subFolder));

			new File(f2, "file2").createNewFile();
			String[] entryNames = fdsa.getEntryNames(subFolder);
			// Order is not specified
			Arrays.sort(entryNames);
			assertEquals("Ticket #21644: Files in other folders than top level folders are not reported.",
				new String[] { subFolder + "file1", subFolder + "file2" }, entryNames);
		} finally {
			FileUtilities.deleteR(f1);
			FileUtilities.deleteR(f2);
		}
	}
	
    // Static methodes

    /**
     * the suite of tests to execute.
     */
	@SuppressWarnings("unused")
	public static Test suite() {

        TestSuite suite = new TestSuite ();
        
        suite.addTest(new TestFilesystemDataSourceAdaptor("cleanupTmp"));
		if (false) {
			suite.addTest(new TestFilesystemDataSourceAdaptor("testEntryAppendStream"));
		} else {
			suite.addTestSuite(TestFilesystemDataSourceAdaptor.class);
		}
        return DSATestSetup.createDSATestSetup(suite);
//        return suite;
    }

    /**
     * main function for direct testing.
     */
    public static void main (String[] args) {
        Logger.configureStdout();
        junit.textui.TestRunner.run (suite ());
    }

}
