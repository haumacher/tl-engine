/*
 * SPDX-FileCopyrightText: 2006 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.layout.form.control;

import java.io.IOException;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import com.top_logic.basic.col.FilterUtil;
import com.top_logic.basic.col.filter.FilterFactory;
import com.top_logic.basic.listener.EventType.Bubble;
import com.top_logic.basic.listener.GenericPropertyListener;
import com.top_logic.basic.xml.TagWriter;
import com.top_logic.layout.DisplayContext;
import com.top_logic.layout.basic.AbstractControl;
import com.top_logic.layout.basic.AbstractVisibleControl;
import com.top_logic.layout.basic.ControlCommand;
import com.top_logic.layout.form.ErrorChangedListener;
import com.top_logic.layout.form.FormConstants;
import com.top_logic.layout.form.FormField;
import com.top_logic.layout.form.HasErrorChanged;
import com.top_logic.mig.html.HTMLUtil;

/**
 * {@link com.top_logic.layout.Control} implementation that displays error messages from possibly
 * multiple {@link FormField}s in the GUI.
 * 
 * <p>
 * The visual properties of this {@link ErrorDisplay} can be configured with an
 * {@link ErrorRenderer}.
 * </p>
 * 
 * @author <a href="mailto:bhu@top-logic.com">Bernhard Haumacher</a>
 */
public class ErrorDisplay extends AbstractVisibleControl implements ErrorChangedListener, HasErrorChanged {

	/**
	 * The set of observed {@link FormField}s.
	 */
	private final Set fields;
	
	/**
	 * The subset of {@link #fields} that currently have an error.
	 */
	private Set errorFields;
	
	/**
	 * The renderer for this {@link com.top_logic.layout.Control}.
	 */
	private ErrorRenderer view;
	
	/**
	 * Construct a new {@link ErrorDisplay} observing the given set of
	 * {@link FormField}s.
	 */
	public ErrorDisplay(Set fields, ErrorRenderer view) {
		super(Collections.<String, ControlCommand>emptyMap());
		
		assert FilterUtil.filterList(FilterFactory.not(FilterFactory.createClassFilter(FormField.class)), fields).size() == 0 : 
			"The set of observed fields only contains FormField implementations.";
		
		assert view != null;
		
		this.fields = fields;
		this.view = view;
	}
	
	@Override
	public Object getModel() {
		return null;
	}

	/**
	 * Checks, whether at least one of the observed {@link FormField}s has an error.
	 * 
	 * <p>
	 * <b>Note:</b> May only be called, if this {@link ErrorDisplay} is
	 * {@link #attach(com.top_logic.layout.ControlScope) attached}.
	 * </p>
	 */
	public boolean hasError() {
		assert errorFields != null : "Is attached.";
		
		return ! errorFields.isEmpty();
	}
	
	/**
	 * The number of observed fields that currently have an error.
	 * 
	 * <p>
	 * <b>Note:</b> May only be called, if this {@link ErrorDisplay} is
	 * {@link #attach(com.top_logic.layout.ControlScope) attached}.
	 * </p>
	 */
	public int getErrorCount() {
		assert errorFields != null : "Is attached.";

		return errorFields.size();
	}
	
	/**
	 * An iterator of all {@link FormField}s that currently {@link FormField#hasError() have
	 * errors}.
	 * 
	 * <p>
	 * <b>Note:</b> May only be called, if this {@link ErrorDisplay} is
	 * {@link #attach(com.top_logic.layout.ControlScope) attached}.
	 * </p>
	 */
	public Iterator getErrorFields() {
		assert errorFields != null : "Is attached.";
		
		return errorFields.iterator();
	}
	
	/**
	 * Implemented to attach this {@link com.top_logic.layout.Control} as {@link GenericPropertyListener} to
	 * all of its observed {@link FormField}s, and to bring its internal state
	 * in sync with its model.
	 * 
	 * @see AbstractControl#attachRevalidated()
	 */
	@Override
	protected void attachRevalidated() {
    	super.attachRevalidated();

		this.errorFields = (Set) FilterUtil.filterInline(FormField.HAS_ERROR, new HashSet(fields));

		for (Iterator it = fields.iterator(); it.hasNext(); ) {
			FormField field = (FormField) it.next();
			field.addListener(FormField.ERROR_PROPERTY, this);
			field.addListener(FormField.HAS_ERROR_PROPERTY, this);
		}
	}
	
	/**
	 * @see #attachRevalidated()
	 * @see AbstractControl#detachInvalidated()
	 */
	@Override
	protected void detachInvalidated() {
    	super.detachInvalidated();

		for (Iterator it = fields.iterator(); it.hasNext(); ) {
			FormField field = (FormField) it.next();
			field.removeListener(FormField.HAS_ERROR_PROPERTY, this);
			field.removeListener(FormField.ERROR_PROPERTY, this);
		}
		
		this.errorFields = null;
	}
	
	@Override
	protected void internalWrite(DisplayContext context, TagWriter out) throws IOException {
		view.writeError(context, out, this);
	}
	
	/**
	 * Implemented to translate the property events generated by the observed
	 * {@link FormField}s into events for the {@link ErrorRenderer}.
	 */
	@Override
	public Bubble handleErrorChanged(FormField sender, String oldError, String newError) {
		if (!skipEvent(sender)) {
			view.handleErrorPropertyChange(this);
		}
		return Bubble.BUBBLE;
	}

	/**
	 * Implemented to translate the property events generated by the observed {@link FormField}s
	 * into events for the {@link ErrorRenderer}.
	 */
	@Override
	public Bubble hasErrorChanged(FormField sender, Boolean oldError, Boolean newError) {
		if (!skipEvent(sender)) {
			boolean oldValue = hasError();
			if (newError.booleanValue()) {
				errorFields.add(sender);
			} else {
				errorFields.remove(sender);
			}
			boolean newValue = hasError();

			if (newValue != oldValue)
				view.handleHasErrorPropertyChange(this, oldValue, newValue);

			// There are more or less error messages, therefore the message of
			// this view has changed.
			view.handleErrorPropertyChange(this);

		}
		return Bubble.BUBBLE;
	}

	private boolean skipEvent(FormField sender) {
		if (errorFields == null) {
			// Late event, after this control has been hidden.
			return true;
		}

		if (!fields.contains(sender)) {
			return true;
		}
		return false;
	}

	@Override
	protected void writeControlClassesContent(Appendable out) throws IOException {
		super.writeControlClassesContent(out);
		HTMLUtil.appendCSSClass(out, FormConstants.IS_ERROR_CSS_CLASS);
		view.appendControlCSSClasses(out, this);
	}

	@Override
	protected String getTypeCssClass() {
		return "cErrorDisplay";
	}

}
