/*
 * SPDX-FileCopyrightText: 2008 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.reporting.report.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import com.top_logic.basic.CollectionUtil;
import com.top_logic.basic.StringServices;
import com.top_logic.basic.config.ConfigurationException;
import com.top_logic.basic.config.InstantiationContext;
import com.top_logic.reporting.report.model.ReportTree.ReportNode;
import com.top_logic.reporting.report.model.aggregation.AggregationFunction;
import com.top_logic.reporting.report.model.aggregation.AggregationFunctionConfiguration;
import com.top_logic.reporting.report.model.aggregation.AggregationFunctionFactory;
import com.top_logic.reporting.report.model.aggregation.AggregationFunctionLabelProvider;
import com.top_logic.reporting.report.model.objectproducer.ObjectProducer;
import com.top_logic.reporting.report.model.objectproducer.ObjectProducerConfiguration;
import com.top_logic.reporting.report.model.objectproducer.ObjectProducerFactory;
import com.top_logic.reporting.report.model.partition.Partition;
import com.top_logic.reporting.report.model.partition.PartitionFunctionConfiguration;
import com.top_logic.reporting.report.model.partition.criteria.Criteria;
import com.top_logic.reporting.report.model.partition.criteria.interval.IntervalCriteria;
import com.top_logic.reporting.report.model.partition.function.AbstractPartitionFunction;
import com.top_logic.reporting.report.model.partition.function.PartitionFunction;
import com.top_logic.reporting.report.model.partition.function.PartitionFunctionFactory;
import com.top_logic.reporting.report.util.ReportConstants;
import com.top_logic.util.Resources;
import com.top_logic.util.TLContext;

/**
 * The RevisedReport contains all necessary information to create a report.
 * 
 * @author <a href="mailto:tbe@top-logic.com">tbe</a>
 */
@Deprecated
public class RevisedReport {
	
    private ReportConfiguration config; 
    
    /**
	 * A producer to retrieve a set of BusinessObjects this report is based on.
	 */
    private ObjectProducer	businessObjectProducer;

	/**
	 * The basic set of objects this Report is based on. Its is created by the
	 * {@link #businessObjectProducer}.
	 */
    private Collection<Object> businessObjects;

	/**
	 * A Report has a {@link List} of {@link Partition}s, in which the underlying
	 * <code>businessObjects</code> are sorted. The sorting is done by a {@link PartitionFunction}.
	 */
    private List<Partition> partitions;

	/**
	 * List of {@link AggregationFunction}s used by this report.
	 */
    private List<AggregationFunction> aggregationFunctions;

	/**
	 * The {@link PartitionFunction}s used by this report. A report exactly one {@link #partitionFunction}.
	 */
    private PartitionFunction partitionFunction;

	/**
	 * The language used for this report.
	 */
    private String language;

	/**
	 * Each report has one {@link DataSet} which encapsulates the data generated by the report. A
	 * {@link DataSet} has at least on {@link DataSeries}.
	 */
    @Deprecated
	private DataSet dataSet;

	private ReportTree reportTree;

	/**
	 * Creates a {@link RevisedReport}.
	 */
	public RevisedReport(InstantiationContext aContext, ReportConfiguration aReportConfiguration) throws ConfigurationException {
		this.language = initLanguage();
		this.config   = aReportConfiguration;
		
		String theCheckResult = checkReportConfiguration(aReportConfiguration);
		
		if (!StringServices.isEmpty(theCheckResult)) {
			throw new ConfigurationException(theCheckResult);
		}
		
		this.initBusinessObjectProducer(aReportConfiguration);
		this.initPartitionFunctions(aReportConfiguration);
		this.initAggregationFunctions(aReportConfiguration);
		
		this.init();
	}

	/** 
	 * Checks whether a given {@link ReportConfiguration} is valid.
	 * 
	 * @param aReportConfiguration a {@link ReportConfiguration} to check
	 * @return <code>null</code> if the given configuration is valid, an error message otherwise.
	 */
	public static String checkReportConfiguration(ReportConfiguration aReportConfiguration) {
		if (CollectionUtil.isEmptyOrNull(aReportConfiguration.getAggregationConfigurations())) {
			return "No AggregationFunctionConfiguration configured.";
		}
		
		if (aReportConfiguration.getPartitionConfiguration() == null) {
			return "No PartitionFunctionConfiguration configured.";
		}
		else if (aReportConfiguration.getPartitionConfiguration().getPartitionConfiguration() != null) {
			if (aReportConfiguration.getAggregationConfigurations().size() > 1) {
				return "If a configured PartitionFunctionConfiguration has itself a PartitionFunctionConfiguration only one AggregationFunctionConfiguration is allowed.";
			}
			if (aReportConfiguration.getPartitionConfiguration().getPartitionConfiguration().getPartitionConfiguration() != null) {
				return "Tree depth to high: A maximum of 2 PartitionFunctionConfigurations is allowed.";
			}
		}
		return null;
	}

	public Collection<?> getRelevantObjectsForItemVO(int aSeries, int aCategory) {
		ReportNode root  = (ReportNode) this.getReportTree().getRoot();
		List<ReportNode> children = root.getChildren();
		if (this.getChartType().equals(ReportConstants.REPORT_TYPE_WATERFALL_CHART) && children.size() == aCategory){
			List<Object> theResult = new ArrayList<>();
			for (ReportNode theNode:children) {
				theResult.addAll(theNode.getChildren().get(aSeries).getObjects());
			}
			return theResult;
		}
		else {
			ReportNode child = children.get(aCategory);
			return child.getChildren().get(aSeries).getObjects();
		}
	}
	
	/**
	 * This method returns the businessObjectProducer.
	 * 
	 * @return Returns the businessObjectProducer.
	 */
	public ObjectProducer getBusinessObjectProducer() {
		return (this.businessObjectProducer);
	}

	/**
	 * This method returns the {@link #businessObjects} produced by the {@link #businessObjectProducer}.
	 * 
	 * @return an unmodifiable {@link Collection} of {@link #businessObjects}. Can be <code>null</code>
	 *         if {@link #initBusinessObjects()} was not called beforehand;
	 */
	public Collection<?> getBusinessObjects() {
		if(this.businessObjects == null) {
			return Collections.EMPTY_LIST;
		}
		else {
			return (Collections.unmodifiableCollection(this.businessObjects));
		}
	}

	/**
	 * This method returns the {@link List} of partitions this report is based upon.
	 * 
	 * @return Returns a {@link List} of partitions.
	 */
	public List<Partition> getPartitions() {
		return (this.partitions);
	}

	/**
	 * This method returns the aggregationFunctions.
	 * 
	 * @return Returns the aggregationFunctions.
	 */
	public List<AggregationFunction> getAggregationFunctions() {
		return (this.aggregationFunctions);
	}

	/**
	 * This method sets the aggregationFunctions.
	 * 
	 * @param someAggregationFunctions
	 *            The aggregationFunctions to set.
	 * @deprecated should use the configuration interface instead.
	 */
	@Deprecated
	public void setAggregationFunctions(List<AggregationFunction> someAggregationFunctions) {
		this.aggregationFunctions = someAggregationFunctions;
	}

	/**
	 * This method returns the partitionFunctions.
	 * 
	 * @return Returns the partitionFunctions.
	 */
	public PartitionFunction getPartitionFunction() {
		return (this.partitionFunction);
	}

	/**
	 * This method returns the language.
	 * 
	 * @return Returns the language.
	 */
	public String getLanguage() {
		return (this.language);
	}

	/**
	 * This method returns the {@link DataSet} this report generated.
	 * 
	 * @return a {@link DataSet} with at least on {@link DataSeries} containing relevant {@link ItemVO}s
	 */
	@Deprecated
	public DataSet getDataSet() {
		return (this.dataSet);
	}

	/**
	 * This method returns the granularity of the first {@link PartitionFunction}. 
	 * 
	 * @return Returns the granularity.
	 */
	public Object getGranularity() {
		Criteria theCriteria = (this.partitionFunction).getCriteria();
		if (theCriteria instanceof IntervalCriteria) {
			return ((IntervalCriteria) theCriteria).getGranularity();
		}
		return null;
	}

	@Deprecated
	public Object getBegin() {
		Criteria theCriteria = (this.partitionFunction).getCriteria();
		if (theCriteria instanceof IntervalCriteria) {
			return ((IntervalCriteria) theCriteria).getBegin();
		}
		return null;
	}

	@Deprecated
	public Object getEnd() {
		Criteria theCriteria = (this.partitionFunction).getCriteria();
		if (theCriteria instanceof IntervalCriteria) {
			return ((IntervalCriteria) theCriteria).getEnd();
		}
		return null;
	}

	@Deprecated
	public Object getTimeRange() {
		Criteria theCriteria = (this.partitionFunction).getCriteria();
		if (theCriteria instanceof IntervalCriteria) {
			Map theAdditionalSettings = (Map) ((IntervalCriteria) theCriteria).getAdditionalSettings();
			return theAdditionalSettings.get("begin_relative");
		}
		return null;
	}

	@Deprecated
	public boolean getRelative() {
		Criteria theCriteria = (this.partitionFunction).getCriteria();
		if (theCriteria instanceof IntervalCriteria) {
			Map theAdditionalSettings = (Map) ((IntervalCriteria) theCriteria).getAdditionalSettings();
			Object theAttributeValue = theAdditionalSettings.get("end_relative");
			if ("absolute".equals(theAttributeValue)) {
				return false;
			}
			else {
				return true;
			}
		}
		return true;
	}

	/** 
	 * @deprecated use {@link ReportConfiguration#getChartType()} instead.
	 */
	@Deprecated
	public String getChartType() {
		return this.config.getChartType();
	}

	public ReportConfiguration getConfiguration() {
	    return this.config;
	}

	/**
	 * Ititalizes the Report and generates the {@link DataSet}.
	 */
	protected void init() {
		initBusinessObjects();
		
		ReportNode                theNode = new ReportNode("rootNode", CollectionUtil.toList(this.getBusinessObjects()));
		AbstractPartitionFunction thePF   = (AbstractPartitionFunction) this.partitionFunction;
		ReportTree                theTree = new ReportTree(theNode);
		
		this.initializeTree(theNode, thePF);
		
		this.reportTree = theTree;
	}

	private void initializeTree(ReportNode aNode, AbstractPartitionFunction aPF) {
		Locale                    theLocale  = TLContext.getLocale();
		List<Partition>           partitions = aPF.processObjects(aNode.getObjects());
		AbstractPartitionFunction theInnerPF = (AbstractPartitionFunction) aPF.getSubPartitionFunction();

		for (int i = 0; i < partitions.size(); i++) {
			Partition    theP       = partitions.get(i);
			List<Object> theObjects = theP.getObjects(false);
			ReportNode theChild   = new ReportNode(theP.getName(theLocale.getLanguage()), theObjects, null, theP.getCriteria(), null);
			aNode.addChild(theChild);
			
			if (theInnerPF != null) {
				this.initializeTree(theChild, theInnerPF);
			}
			else {
				for (int j = 0; j < this.getAggregationFunctions().size(); j++) {
					AggregationFunction              theAF     = this.getAggregationFunctions().get(j);
					AggregationFunctionConfiguration theConfig = (AggregationFunctionConfiguration) this.config.getAggregationConfigurations().get(j);
					AggregationFunctionLabelProvider theLabelProvider = this.config.getAggregationFunctionLabelProvider();
					String                           funcName  = theLabelProvider.getLabel(theConfig, this.getConfiguration());//ConfigurationDescriptorResourceProvider.INSTANCE.getLabel(theAF.getClass());
					ReportNode                       theLeaf   = new ReportNode(funcName, theObjects, theAF.getValueObjectFor(theObjects).getValue(), null, theConfig);
					theChild.addChild(theLeaf);
				}
			}
		}
	}

	private void initPartitionFunctions(ReportConfiguration aReportConfiguration) {
	    PartitionFunctionFactory       theFac  = PartitionFunctionFactory.getInstance();
	    PartitionFunctionConfiguration theConf = aReportConfiguration.getPartitionConfiguration();
	    PartitionFunction              theFunc = theFac.getPartitionFunction(theConf);
	    
	    this.partitionFunction = theFunc;
	}

	private void initAggregationFunctions(ReportConfiguration aReportConfiguration) {
	    AggregationFunctionFactory theFac = AggregationFunctionFactory.getInstance();
	    List<AggregationFunctionConfiguration> theAggrConf = aReportConfiguration.getAggregationConfigurations();
	    if (theAggrConf != null) {
	        int  theSize     = theAggrConf.size();
	        this.aggregationFunctions = new ArrayList<>(theSize);
	        for (int i=0; i<theSize; i++) {
	            AggregationFunctionConfiguration theConf = theAggrConf.get(i);
	            AggregationFunction              theFunc = theFac.getAggregationFunction(theConf);
	            this.aggregationFunctions.add(theFunc);
	        }
	    }
	}

	private void initBusinessObjectProducer(ReportConfiguration aReportConfiguration) {
	    ObjectProducerConfiguration theConf = aReportConfiguration.getBusinessObjectProducer();
	    this.businessObjectProducer = ObjectProducerFactory.INSTANCE.getObjectProducer(theConf);
	 }

	/**
	 * Takes the {@link #businessObjectProducer} and sets the {@link #businessObjects} to the producers
	 * {@link Collection} of objects.
	 */
	private void initBusinessObjects() {
		this.businessObjects = this.businessObjectProducer.getObjects();
	}

	/**
	 * Initialize the report with the current user language.
	 */
	private String initLanguage() {
		return Resources.getInstance().getLocale().getLanguage();
	}

	public ReportTree getReportTree() {
		return this.reportTree;
	}
}
