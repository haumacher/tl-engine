/*
 * SPDX-FileCopyrightText: 2005 (c) Business Operation Systems GmbH <info@top-logic.com>
 * 
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-BOS-TopLogic-1.0
 */
package com.top_logic.element.layout.structured;


import com.top_logic.base.bus.MonitorEvent;
import com.top_logic.basic.StringServices;
import com.top_logic.basic.config.InstantiationContext;
import com.top_logic.element.core.util.ElementEventUtil;
import com.top_logic.element.meta.form.component.AbstractApplyAttributedCommandHandler;
import com.top_logic.element.structured.StructuredElement;
import com.top_logic.layout.form.model.FormContext;
import com.top_logic.layout.form.model.SelectField;
import com.top_logic.layout.form.model.StringField;
import com.top_logic.mig.html.layout.LayoutComponent;


/**
 * Handler for applying changes to a structured element.
 * 
 * TODO MGA: extract an AttributedApplyHandler.
 * 
 * @author     <a href="mailto:mga@top-logic.com">Michael Gänsler</a>
 */
public class StructuredElementApplyHandler extends AbstractApplyAttributedCommandHandler {

    /** The unique ID of this handler. */
    public static final String COMMAND = "elementApply";

    public StructuredElementApplyHandler(InstantiationContext context, Config config) {
		super(context, config);
    }

    @Override
	protected boolean storeChanges(LayoutComponent component, FormContext formContext, Object model) {
		StringField theField = (formContext.hasMember(AdminElementComponent.ELEMENT_NAME))
			? (StringField) formContext.getField(AdminElementComponent.ELEMENT_NAME)
			: null;
		String theName = null;
		StructuredElement theNext = null;
		boolean hasChanged = false;
		boolean hasMoved = false;

		if ((theField != null) && theField.isChanged()) {
			hasChanged = true;
			theName = (String) theField.getValue();
		}

		SelectField theSelect = (formContext.hasMember(AdminElementComponent.ELEMENT_ORDER))
			? (SelectField) formContext.getField(AdminElementComponent.ELEMENT_ORDER)
			: null;

		if (hasChanged || ((theSelect != null) && theSelect.isChanged())) {
			hasChanged = true;
			hasMoved = true;

			if (theSelect != null) {
				theNext = (StructuredElement) theSelect.getSingleSelection();
			}
		}

		hasChanged = this.saveMetaAttributes(formContext) || hasChanged;

		boolean theResult = this.updateElement((StructuredElement) model, theName, theNext, hasMoved) || hasChanged;

		if (theResult && model instanceof StructuredElement) {
			this.sendEvent((StructuredElement) model);
        }
        
        return theResult;
    }

    /**
     * Updates anElement with the given values and cares about move.
     * This method does not send any MonitorEvents.
     * If you want to do so, use {@link #sendEvent(StructuredElement)}
     * with the changed element afterwards.
     * 
     * <code>public</code> to allow chaining.
     * 
     * @param    anElement    The element to be changed, must not be <code>null</code>.
     * @param    aName        The new name to be set, may be <code>null</code>, 
     *                        which will leave the name unchanged.
     * @param    aNext        The ID of the next element sibling, may be 
     *                        <code>null</code>, which will move the element to 
     *                        the begin  of the sibling list.
     * @param    hasMoved     Flag, if object has to be moved. 
     * @return   <code>true</code>, if changing the element succeeds.
     */
    public boolean updateElement(StructuredElement anElement, String aName, StructuredElement aNext, boolean hasMoved) {
        boolean changed = false;
        if (!StringServices.isEmpty(aName)) {
            anElement.setElementName(aName);
            changed = true;
        }

        StructuredElement theParent = anElement.getParent();

        if ((theParent != null) && hasMoved) {
            changed = changed | theParent.move(anElement, aNext); 
        }
        return changed;
    }

    /**
     * Hook for subclasses. This method sends a MonitorEvent on the ModelTrackinUtil.
     * Overwrite this method if you want to deactivate or send special MonitorEvents.
	 * Use this method if you want to generate MonitorEvents outside a GUI-Context.
     * MonitorEvents are generated by default.  
     * 
     * @param anElement the changed element
     */
    public void sendEvent(StructuredElement anElement) {
        ElementEventUtil.sendEvent(anElement, MonitorEvent.MODIFIED);
    }
}
